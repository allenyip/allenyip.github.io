<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Allen Yip on Allen Yip</title>
    <link>https://allenyip.github.io/</link>
    <description>Recent content in Allen Yip on Allen Yip</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 01 Jun 2019 00:00:00 +0000</lastBuildDate>
    <atom:link href="/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>About</title>
      <link>https://allenyip.github.io/about/</link>
      <pubDate>Sat, 01 Jun 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/about/</guid>
      <description>&lt;p&gt;A minimalist.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>清迈游记</title>
      <link>https://allenyip.github.io/2019/chiengmai-travel/</link>
      <pubDate>Wed, 01 May 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2019/chiengmai-travel/</guid>
      <description>&lt;p&gt;小猪同学又跳槽了，于是两人筹划着趁劳动节假期出去走走，不知道怎么商量最后就定了泰国。一开始想五天把曼谷清迈走遍，后面因为两个人太懒放弃了，还是清迈悠闲的晃一晃就好。&lt;/p&gt;

&lt;p&gt;行程大致如下：&lt;/p&gt;

&lt;p&gt;DAY 1：深圳-曼谷-清迈，入住的酒店在古城东南边，比较安静些，下次来可以选在古城里或者宁曼路上，更热闹。小猪同学从昆明出发，两个人酒店会和后出去吃了个午饭，回酒店睡了一大觉。&lt;/p&gt;

&lt;p&gt;DAY 2：古城瞎逛，把一些大寺庙逛了个遍，感叹泰国人民真是虔诚。&lt;/p&gt;

&lt;p&gt;DAY 3：报了个清莱一日游，白庙真的太好看，晚上回宁曼璐逛吃。&lt;/p&gt;

&lt;p&gt;DAY 4：小猪同学跟着新认识的朋友鬼混一夜后，后面两天都顾着瘫了，我自己包了个车来双龙寺，正好遇到昨天团里的两个中国人。下午在宁曼璐逛吃，晚上跟另一个朋友，骑着滑板车在古城瞎转悠。&lt;/p&gt;

&lt;p&gt;DAY 5：去了下尚泰，没买到什么东西，启程回深圳了，想要的东西在免税商场买到了。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>看《绿皮书》</title>
      <link>https://allenyip.github.io/2019/green-book/</link>
      <pubDate>Mon, 11 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2019/green-book/</guid>
      <description>&lt;p&gt;本片基于真实故事改编，虽然与真实故事存在一些令人反感的出入，但仅从电影本身来看，我认为是一部久违的好电影。&lt;/p&gt;

&lt;p&gt;电影讲述的是一位优雅的黑人音乐家聘请一位粗鲁的白人司机，到种族歧视严重的南部巡回演出的故事。一路上欢声笑语，有血有泪，印象比较深刻的有以下几个场景：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;汽车在田边故障，白人司机停下来修车，黑人音乐家在汽车后座坐着，与田里劳作的黑人们互相对望，形成鲜明对比。&lt;/li&gt;
&lt;li&gt;黑人音乐家教白人司机写信，白人司机教黑人音乐家如何正确吃炸鸡。&lt;/li&gt;
&lt;li&gt;尽管是世界知名的音乐家，受邀到各处表演地仍然没法受到平等对待，但是无论如何，黑人音乐家一直坚持维护好自己的尊严。&lt;/li&gt;
&lt;li&gt;司机说：孤独的人都害怕迈出第一步。&lt;/li&gt;
&lt;li&gt;音乐家说：自己不像白人，不像黑人，不够男人，那我到底算什么？&lt;/li&gt;
&lt;li&gt;罢演之后，音乐家在一间黑人酒吧弹奏了肖邦的练习曲，接受并找回了自我。&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>看《徒手攀岩》</title>
      <link>https://allenyip.github.io/2019/free-solo/</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2019/free-solo/</guid>
      <description>&lt;p&gt;看了最近拿奖的纪录片《徒手攀岩》，讲的是攀岩大师Alex Honnold徒手登上优胜美地酋长石的故事。主角真的太迷人了，忍不住想分享一些关于他的故事：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;从小学攀岩，19岁父亲心脏病猝死后，开始辍学独自驾着房车四处攀岩，被问到是否害怕死亡时，他回答：每个人随时都可能会死，徒手攀岩只是将这种可能更快的展现在你面前。（应该是理性又偏执的人，征服自然的精神已经超越了生死，当然，也超过了家人的担心和对他人的责任…）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;学攀岩时保持每周六天，每天三小时的不间断训练。每次徒手攀之前都会做好计划，反复训练，确保万无一失。（天赋很重要，但更重要的是正确的方法加上无数次的练习）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;崇尚武士精神，认为人生应该追求有所成就，而非舒适和幸福，后者是平庸且对世界无益的。（emm，取得成就是伟大的，但我认为追求舒适和幸福一点都不平庸）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;对物质欲望不大，没有买房只有一辆房车，不吃肉只吃蔬菜，吃饭不爱用碗碟直接用锅和铲吃（极简主义可借鉴And很好奇不吃肉他这一身肌肉是怎么来的，蛋白粉当水喝吗）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;原生家庭从未表达过爱，甚至从未拥抱过，32岁人生走上巅峰了性格仍有缺陷，隐约能看出感情较淡、共情能力较差。（恋爱关系似乎有在填补这部分缺陷）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;影片最后有两处太有意思了，一个是登顶后取得了巨大成就的Alex（他居然能忍着没哭，情感有够压抑的）跟泣不成声的女友打电话，很不自在的说了句I Love You。另一个是被采访到接下来有什么打算时，这哥们云淡风轻的说了句：我等下要去做个悬挂训练。。。尼玛要不要这么自律啊&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>看《黑镜：潘达斯奈基》</title>
      <link>https://allenyip.github.io/2019/black-mirror/</link>
      <pubDate>Mon, 04 Mar 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2019/black-mirror/</guid>
      <description>&lt;p&gt;尽管一季不如一季，《黑镜》目前仍是我最爱的英剧之一，S01E01首相操猪给我的震撼到现在还记忆犹新。&lt;/p&gt;

&lt;p&gt;此次《黑镜：潘达斯奈基》由Netflix制作，不得不说，Netflix从一个DVD租赁平台发展到现在，成为全世界一流的影视媒体公司是有一定道理的，此次黑镜便是一次勇敢的电影游戏化尝试。&lt;/p&gt;

&lt;p&gt;懒得折腾了所以直接看了自带各种结局的电影版，大致了解了这部游戏电影的形式，到某个特定环节，会等待观众进行选择，根据观众的选项来决定剧情走向。更巧的是，电影的主角同样在制作一款类似的游戏，游戏名就叫潘达斯奈基。&lt;/p&gt;

&lt;p&gt;就像我们玩游戏时，有无限次重来的机会，电影中的游戏天才科林意识到自己不过是某款游戏的某次剧情中的某个角色，可以毅然的从阳台跳下自杀。这里要扯到多重宇宙有点牵强了，更多的是像明日边缘里无限重生的阿汤哥，仅仅是游戏化而已。&lt;/p&gt;

&lt;p&gt;电影中的角色们能意识到自己的身不由己，自己的人生是由外部世界的观众来决定，而观影的观众们也并非上帝，编剧早已将所有结局都安排好，只是借观众之手来推动剧情而已。整部剧的根本其实只是一副编程好的流程图。&lt;/p&gt;

&lt;p&gt;其中有个结局很有意思，可能是在向《楚门的世界》致敬，主角最后发现自己其实是个片场演员，人生就是一场戏。这不禁让我想到我的哲学启蒙读物《苏菲的世界》，书中主角由一封书信开始，一步步接触哲学，到最后甚至意思到自己可能只是某个作者的虚构世界中的一个虚构人物而已。&lt;/p&gt;

&lt;p&gt;对现实世界的我们来说，又何尝不是这样呢，也许在另一个外部世界，也同样有人扮演着上帝的角色，在操控着你。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>读《奇特的一生》</title>
      <link>https://allenyip.github.io/2019/wonderful-life/</link>
      <pubDate>Sun, 24 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2019/wonderful-life/</guid>
      <description>&lt;p&gt;下午健完身去书城翻看了这本书，之前也看过一些关于时间管理方面的书，这本书更像是一部传记而非之前的工具书。&lt;/p&gt;

&lt;p&gt;柳比歇夫这个名字也是跟着这几本书火起来的，近代伟人们总是能给人惊喜，居然有人可以每天记录这种无所事事的流水账，坚持了一辈子，言行合一开创了时间统计的先河。&lt;/p&gt;

&lt;p&gt;是否可以像记账软件一样，将时间类比为金钱，对每个事件花费的时间做个记录呢？身为一个程序员，有空我可以自己开发一个试试。&lt;/p&gt;

&lt;p&gt;我想，光有记录和统计是不够的，还需对数据进行分析，目前我仍未找到对自己统计时间如何进行分析处理的方法，后续再研究下。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>看《遗愿清单》</title>
      <link>https://allenyip.github.io/2019/the-bucket-list/</link>
      <pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2019/the-bucket-list/</guid>
      <description>&lt;p&gt;两个得癌症快死掉的老头一起环游世界，做此生想做未做的事，这件事本身听起来就很酷。&lt;/p&gt;

&lt;p&gt;观影过程中有一点一直让我很出戏，看到摩根弗里曼在片中专一、忠贞的形象，总让我不自觉想到现实中这位好莱坞影星各种性侵的新闻，还是没法跳脱啊。&lt;/p&gt;

&lt;p&gt;总之最后老头跟土豪出去浪了一圈回来后，才更加发现伴侣和家庭的可贵，老伴评价他不知道为什么，变得跟以前一样棒了。土豪最后也在他的推动下，跟自己多年未联系的女儿重新建立的联系。毕竟家庭总是最重要的。&lt;/p&gt;

&lt;p&gt;片中遗愿清单的做法就跟我一直以来列的人生目标有点类似，尽管我个人觉得人活着是无意义的，也不存在所谓与生俱来的使命，就像宇宙中的一粒沙砾。但是对待人生我仍回选择，多去经历，多去体验，丰富自己的内心，在死亡来临时尽量做到没有遗憾。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>读《自控力》</title>
      <link>https://allenyip.github.io/2019/self-control/</link>
      <pubDate>Sat, 26 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2019/self-control/</guid>
      <description>&lt;p&gt;本书采用大量可实践方法，帮助读者提高自身的自控力，可能是因为本人自控力还不错，以及书中大量例子都是跟吃有关，让我这个不爱吃的人没法完全感动身受。&lt;/p&gt;

&lt;p&gt;在我看来，自控力确实是可锻炼的，以前我也不是这么自律的人，随着年龄增长，知道什么才是自己真正想要的，就开始努力提升自己，变得越来越自律（但欲望也越来越低）&lt;/p&gt;

&lt;p&gt;书中还有个观点挺赞同的，关于平衡和守恒，有点类似初中物理的能量守恒定律。比如某人在A上特别自律，在B上可能就显得懒散，区别在于A和B对他的重要程度以及喜爱程度，自控力的平衡也在于很好的协调好各类AB角，像我在健身期，每周日会安排一个间歇日适当放纵，不会使自己一直在一个紧绷的状态下导致自控力失衡。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>看《无名之辈》</title>
      <link>https://allenyip.github.io/2019/a-cool-fish/</link>
      <pubDate>Wed, 16 Jan 2019 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2019/a-cool-fish/</guid>
      <description>&lt;p&gt;一直很喜欢类似《疯狂的石头》这类的小成本黑色幽默喜剧，尤其是剧本和电影本身的多条线的叙事。这部剧虽比不上《石头》，但是在剧本上还是有许多令人喜欢的地方：&lt;/p&gt;

&lt;p&gt;不敢抢银行只好抢了银行旁边的手机店里的手机模型的安全帽劫匪&lt;/p&gt;

&lt;p&gt;嘴巴毒辣的截瘫女和一心想当大哥的憨批劫匪的爱情故事&lt;/p&gt;

&lt;p&gt;一心一意爱着按摩女人生理想是娶她回家给她买棒棒糖的舔狗劫匪&lt;/p&gt;

&lt;p&gt;执着于再度当上协警不遗余力追查与自己不相关案件的保安&lt;/p&gt;

&lt;p&gt;……&lt;/p&gt;

&lt;p&gt;其他的不说，单是这几个人物设定就十分讨人喜欢，导演通过相互联系的几出荒诞喜剧将这几个小人物串联在一起，但是也存在一些不合理的地方，很多叙事并没有抓住人性的特点，而有些流于表面，仔细推敲后觉得似乎对人物的刻画还不够深刻，剧中也未出现较大的戏剧冲突。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>西北游记</title>
      <link>https://allenyip.github.io/2015/northwest-travel/</link>
      <pubDate>Sun, 31 May 2015 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2015/northwest-travel/</guid>
      <description>&lt;p&gt;毕业论文完成后，几个同学筹划着到大西北走一圈，作为一个凑人头的佛系青年，抱着别人大腿出行真是太方便了，什么事都不需要自己操心。&lt;/p&gt;

&lt;p&gt;行程大致如下：&lt;/p&gt;

&lt;p&gt;DAY 1：厦门飞西安，作为行程起点，一座历史古都，对历史不怎么感兴趣的我，主要目的就是来吃东西。&lt;/p&gt;

&lt;p&gt;DAY 2：回民街逛吃，坐车参观了华清池和秦始皇陵兵马俑，傍晚回古城墙伴着夕阳骑自行车，爽歪歪。&lt;/p&gt;

&lt;p&gt;DAY 3：回民街逛吃，参观高家大院、小雁塔没开放，看了大雁塔，参观了陕西省博物馆。&lt;/p&gt;

&lt;p&gt;DAY 4：西安飞往西宁，到莫家街吃了碗炮仗。&lt;/p&gt;

&lt;p&gt;DAY 5：租车自驾，先到茶卡盐湖（不知道是正在清理还是什么原因，感觉脏脏的），之后是青海湖开车环湖，太美了，一路都是美景，随手一拍都是壁纸系列，以后有机会得再来一次。&lt;/p&gt;

&lt;p&gt;DAY 6：西宁高铁到张掖，包车到丹霞地质公园，见识了大自然的鬼斧神工。晚上夜班火车出发前往敦煌。&lt;/p&gt;

&lt;p&gt;DAY 7：白天去了鸣沙山、月牙泉、莫高窟，晚上敦煌夜市逛吃。&lt;/p&gt;

&lt;p&gt;DAY 8：散客拼团，一路参观了敦煌古城、阳光、玉门关、汉长城、西千佛洞、雅丹。晚上夜班火车前往兰州。&lt;/p&gt;

&lt;p&gt;DAY 9：黄河边上吃了碗兰州拉面，飞回厦门。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>看《IT狂人》</title>
      <link>https://allenyip.github.io/2013/the-it-crowd/</link>
      <pubDate>Fri, 04 Oct 2013 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2013/the-it-crowd/</guid>
      <description>&lt;p&gt;作为一个闷骚的IT死宅，文字已经无法形容我的喜爱。&lt;/p&gt;

&lt;p&gt;等了几年才迎来取代第五季的完结篇，抱怨感慨的同时也只能默默接受。
在平板上勉强地看着无字幕的这集，一如既往没心没肺地笑着，
直到最后Moss不舍地关上了房间的灯，留给我印象最深的。&lt;/p&gt;

&lt;p&gt;不是那个又呆又萌的爆炸头，&lt;/p&gt;

&lt;p&gt;不是那个邋遢懒散的小眼睛，&lt;/p&gt;

&lt;p&gt;不是那个可爱豪放的女主管，&lt;/p&gt;

&lt;p&gt;不是那个浮夸神经的络腮胡，&lt;/p&gt;

&lt;p&gt;不是那个神秘孤独的哥特男。&lt;/p&gt;

&lt;p&gt;而是地下室里的每一个玩偶，每一只模型，每一张贴纸，每一件T恤&amp;hellip;&lt;/p&gt;

&lt;p&gt;这一切都太过可爱，好想把它们全部买来。&lt;/p&gt;

&lt;p&gt;影片最后，Roy终于讲出了那句台词，Turn it off and on again，说再见之前，我又把最爱的片头看了一遍。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Java基础</title>
      <link>https://allenyip.github.io/2013/java-basic/</link>
      <pubDate>Fri, 15 Mar 2013 00:00:00 +0000</pubDate>
      
      <guid>https://allenyip.github.io/2013/java-basic/</guid>
      <description>&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#data&#34;&gt;基本数据结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#oper&#34;&gt;操作符&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#flow&#34;&gt;控制执行流程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#init&#34;&gt;初始化与清理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#acce&#34;&gt;访问权限控制&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#reus&#34;&gt;复用类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#inte&#34;&gt;接口&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#inne&#34;&gt;内部类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#coll&#34;&gt;容器类&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#exce&#34;&gt;异常&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#stri&#34;&gt;字符串&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#type&#34;&gt;类型信息&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#geri&#34;&gt;泛型&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#enum&#34;&gt;枚举&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#arra&#34;&gt;数组&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#anno&#34;&gt;注解&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#io&#34;&gt;Java I/0&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#conc&#34;&gt;并发&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;data&#34;&gt;基本数据类型&lt;/h2&gt;

&lt;p&gt;1，Java里的数据类型分为基本类型和引用类型。基本类型可直接创建赋值并存储于&lt;strong&gt;栈&lt;/strong&gt;中，引用类型或通过new关键字创建并存储于&lt;strong&gt;堆&lt;/strong&gt;中，或直接存储于String常量池中。&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;Java有六个地方可以存储数据，按照存取速度排列：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;寄存器Register：位于处理器内部，由编译器分配，无法控制&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;栈Stack：存放基本类型的数据和对象/数组的引用，但对象本身不存在栈中，而存在堆中（new出来的对象）或者字符串常量池中&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;堆Heap：堆比栈更加灵活，无需知道分配了多少空间，也无需知道对象存活多长时间。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;静态存储：存放程序运行时一直存在的数据&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;常量存储：直接存放在程序代码内部，存放字符串常量和基本类型常量（public static final）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;非RAM存储：如硬盘等永久存储空间，完全存活于程序之外，不受程序的任何控制。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注：对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。&lt;/p&gt;

&lt;p&gt;注2：对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;String s = new String(“xyz”);产生几个对象？如果常量池中有xyz则只在堆中产生一个拷贝对象（一个）；如果常量池中没有xyz，则在常量池中创建xyz，然后在堆中创建拷贝（两个）。&lt;/p&gt;

&lt;p&gt;2，由于JVM是独立于底层的机器，基本数据类型大小是固定的，因此Java也不需要sizeof操作。基本数据类型及其大小如下所示：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;boolean，-，大小未明确定义，仅定义为字面值true/false，默认值false。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;char，16位，默认值\u0000(null)。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;byte，8位，默认值(byte)0。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;short，16位，默认值(short)0。所有数值类型都有正负号！&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;int，32位，默认值0。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;long，64位，默认值0L。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;float，32位，默认值0.0f。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;double，64位，默认值0.0d。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;void，-&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;基本类型在作为类的成员时会被赋予默认值，即使未进行初始化也能运行；而作为局部变量，如位于方法中而不是类中，其默认值可能是任意的，并且在运行时会报错。（类变量同理，默认赋予null值）&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;3，除了继承自C++的单行注释//和多行注释/* * /，Java提供了文档注释/** * /，方便开发人员生成代码文档，注释文档分为类、域和方法三种，只能对public和protected成员进行注释。有两种使用方式：嵌入式HTML和文档标签（@开头）。一个示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.util.*;

/** The first Java example
 *  Display today&#39;s date
 *  @author Allen Yip
 *  @version 1.0
 */
public class HelloDate {
    /** Entrv point to application
     *  @param args array of arguments
     */
    public static void main(String[] args) {
        System.out.println(new Date());
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;oper&#34;&gt;操作符&lt;/h2&gt;

&lt;p&gt;1，赋值时，基本数据类型会直接将值复制，而类（对象）则只赋值引用，示例如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Tank {
    int level;
}

public class Test {
    public static void main(String[] args) {
        Tank t1 = new Tank();
        Tank t2 = new Tank();
        t1.level = 1;
        t2.level = 2;
        System.out.println(&amp;quot;1. t1.level=&amp;quot; + t1.level + &amp;quot; t2.level=&amp;quot; + t2.level);
        t1 = t2; // 使用 t1.level = t2.level 来避免别名现象
        System.out.println(&amp;quot;2. t1.level=&amp;quot; + t1.level + &amp;quot; t2.level=&amp;quot; + t2.level);
        t1.level = 99;
        System.out.println(&amp;quot;3. t1.level=&amp;quot; + t1.level + &amp;quot; t2.level=&amp;quot; + t2.level);
    }
} /* Output:
1: t1.level=1 t2.level=2
2: t1.level=2 t2.level=2
3: t1.level=99 t2.level=99
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2，关系操作符 == 和 != 经常会令人迷惑：&lt;/p&gt;

&lt;p&gt;对于基本类型，==是比较它们的值是否相等；对于复杂类型，==则是比较它们在内存的存放地址是否相等（即两个引用是否指向同一对象），若要比较值需要重写equals方法（以及hashCode方法）。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
class Value {
    int i;
}
public class Test {
    public static void main(String[] args) {
        int a1 = 47, a2 = 47;
        Integer b1 = new Integer(47);
        Integer b2 = new Integer(47);
        System.out.println(a1 == a2);
        System.out.println(b1 == b2);
        System.out.println(b1.equals(b2));

        // 自定义类
        Value v1 = new Value();
        v1.i = 47;
        Value v2 = new Value();
        v2.i = 47;
        System.out.println(v1.equals(v2));// 未覆盖equals方法
    }
} /* Output:
true
false
true
false
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3，移位操作符中，左移&amp;lt;&amp;lt;在低位补0；有符号右移&amp;gt;&amp;gt;使用符号扩展：符号位正则高位补0，为负则高位补1；Java增加了无符号右移&amp;gt;&amp;gt;&amp;gt;操作，使用零扩展：无论正负高位都补0。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        int i = -1;
        System.out.println(Integer.toBinaryString(i));
        i &amp;gt;&amp;gt;&amp;gt;= 10;
        System.out.println(Integer.toBinaryString(i));
    }
} /* Output:
11111111111111111111111111111111
1111111111111111111111
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4，Java中对于boolean类型支持的操作只有：赋予true/false值、测试其真假。除此之外，对其加减等其他任何运算都会报错。除了boolean类型外的其他基本类型都可通过类型转换转变为其他基本类型，转换过程中必须留意“窄化转换”结果，否则可能会出现编译器无法预知的严重错误。&lt;/p&gt;

&lt;h2 id=&#34;flow&#34;&gt;控制执行流程&lt;/h2&gt;

&lt;p&gt;以下例子展示了break和continue的区别：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args) {
        for (int i = 0; i &amp;lt; 100; i++) {
            if (i == 74) break; // out of loop
            if (i % 9 != 0) continue; // next iteration
            System.out.println(i + &amp;quot;&amp;quot;);
        }
    }
} /* Output:
0 9 18 27 36 45 54 63 72
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5，除了单目运算符（! ~ ++ &amp;ndash; +(单操作符) -(单操作符)）、条件运算符（? :）和赋值运算符（= += -= *= /= %= ^= &amp;lt;&amp;lt;= &amp;gt;&amp;gt;= &amp;gt;&amp;gt;&amp;gt;=）是从右到左的顺序，其余运算都是从左往右。&lt;/p&gt;

&lt;h2 id=&#34;init&#34;&gt;初始化与清理&lt;/h2&gt;

&lt;p&gt;Java尽力保证所有变量在使用前都能得到初始化，默认构造器（无参构造器）在未显示定义构造器时会自动创建，若已定义则不会自动创建。方法重载根据参数类型列表，而非返回值（会产生歧义）。&lt;strong&gt;变量定义的先后顺序决定了它的初始化顺序，即使变量定义散布于方法定义之间，它们仍旧会在任何方法之前（包括构造器方法）被初始化&lt;/strong&gt;。例子如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Window {
    Window(int marker) {
        System.out.println(&amp;quot;Window(&amp;quot; + marker + &amp;quot;)&amp;quot;);
    }
}
class House {
    Window w1 = new Window(1); // before constructor
    House() {
        System.out.println(&amp;quot;House()&amp;quot;);
        w3 = new Window(33);
    }
    Window w2 = new Window(2); // after constructor
    void f() { System.out.println(&amp;quot;f()&amp;quot;);}
    Window w3 = new Window(3);
}
public class Test {
    public static void main(String[] args) {
        House h = new House();
        h.f();
    }
} /* Output:
Window(1)
Window(2)
Window(3)
House()
Window(33)
f()
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对象初始化流程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对象在初始化过程，JVM会先去搜索该类的顶级父类，直到搜索到继承树上的Object类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;然后JVM按照继承树往下搜索，继续加载该类的子类，按照静态成员函数-&amp;gt;静态成员变量-&amp;gt;静态初始化块的顺序往下递归，直到加载完我们使用的对象所在的类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;类加载完了过后开始对类进行实例化操作，这个过程还是会先搜索到Object类&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;之后，JVM会递归往继承树下边进行调用，按照成员函数-&amp;gt;成员变量-&amp;gt;构造函数的顺序，实例化该类的成员函数，然后实例化成员变量，执行构造函数&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;5. 最后直到最终类的构造函数调用完成&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;acce&#34;&gt;访问权限控制&lt;/h2&gt;

&lt;p&gt;Java中的访问权限控制等级从大到小依次为：public、protected、包访问权限（没有关键词/可表示为friendly、默认）和private。&lt;/p&gt;

&lt;p&gt;当编译一个.java源文件时（此文件被称为编译单元），文件可以有一个public类并且该类名与文件名相同（最多只能有一个public），若该编译单元内还有其他类，这些类在包之外的世界是不可见的。&lt;/p&gt;

&lt;p&gt;Java解释器的运行过程如下：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;找出环境变量CLASSPATH，CLASSPATH包括一个或多个目录，用于查找.class文件的根目录。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，产生一个路径。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将路径与CLASSPATH链接即为所要查找的.class文件路径。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;类的访问权限总是public或包访问权限（内部类除外），如果不希望该类被访问可以把所有构造器都指定为private，此时，除了通过类内部的static成员，其他类无法直接访问该类。&lt;/p&gt;

&lt;h2 id=&#34;reus&#34;&gt;复用类&lt;/h2&gt;

&lt;p&gt;1，使用组合或者继承来复用类，组合是将对象引用置于新类中，继承则是面向对象的四大特性之一，优先使用组合，如果需要向上转型（派生类可以替换基类）则使用继承。&lt;/p&gt;

&lt;p&gt;实际项目中常常会结合使用组合和继承：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Plate {
    Plate(int i) {
        System.out.println(&amp;quot;Plate constructor&amp;quot;);
    }
}

class DinnerPlate extends Plate {
    DinnerPlate(int i) {
        super(i);
        System.out.println(&amp;quot;DinnerPlate constructor&amp;quot;);
    }
}

class Utensil {
    Utensil(int i) {
        System.out.println(&amp;quot;Utensil constructor&amp;quot;);
    }
}

class Spoon extends Utensil {
    Spoon(int i) {
        super(i);
        System.out.println(&amp;quot;Spoon constructor&amp;quot;);
    }
}

class Fork extends Utensil {
    Fork(int i) {
        super(i);
        System.out.println(&amp;quot;Fork constructor&amp;quot;);
    }
}

class Custom {
    Custom(int i) {
        System.out.println(&amp;quot;Custom constructor&amp;quot;);
    }
}

public class PlaceSetting externds Custom {
    private Spoon sp;
    private Fork fk;
    private DinnerPlate pl;
    public PlaceSetting(int i) {
        super(i + 1);
        sp = new Spoon(i + 2);
        fk = new Fork(i + 3);
        pl = new DinnerPlate(i + 4);
        System.out.println(&amp;quot;PlaceSetting constructor&amp;quot;);
    }
    public static void main(String[] args) {
        PlaceSetting x = new PlaceSetting(9);
    }
} /* Output:
Custom constructor
Utensil constructor
Spoon constructor
Utensil constructor
Fork constructor
Plate constructor
DinnerPlate constructor
PlaceSetting constructor
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2，static关键字可以将对象固定在一个存储空间，可以满足两种需要：只想为某特定域分配单一存储空间；希望某个方法不与包含它的类的任何对象关联。static修饰的变量或方法与类打交道，类无需实例化；非static变量或方法则与对象打交道。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Value1 {
    int x = 1;
    Integer i = new Integer(47);
}

class Value2 {
    static Integer i = new Integer(47);
}

public class House {
    public static void main(String[] args) {
        Value1 a1 = new Value1();
        Value1 a2 = new Value1();
        System.out.println(a1.x == a2.x);
        System.out.println(a1.i == a2.i);
        Value2 b1 = new Value2();
        Value2 b2 = new Value2();
        System.out.println(b1.i == b2.i);
    }
} /* Output:
true
false
true
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3，使用final关键字分为三种情况：数据、方法和类。&lt;/p&gt;

&lt;p&gt;final成员变量表示常量，只能在定义处（只定义未赋值成为空白final）或者构造函数中赋值赋一次值，并且赋值后值不再改变。当final修饰参数时表示参数无法被更改。&lt;/p&gt;

&lt;p&gt;使用final方法的原因是为了锁定方法防止被任何继承类修改，类中所有的private方法默认都是final的。&lt;/p&gt;

&lt;p&gt;当某个类定义为final时，它无法被继承，亦即final类中所有的方法都是隐式final的。&lt;/p&gt;

&lt;p&gt;一个既是static又是final的域（编译器常量）是恒定不变的，且存储于一段不能改变的存储空间。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Value {
    int i;
    public Value(int i) {
        this.i = i;
    }
}

public class House {
    private static Random rand = new Random(47);
    private String id;

    public House(String id) {
        this.id = id;
    }

    // 编译常量
    private final int valueOne = 9;
    private static final int VALUE_TWO = 99;
    public static final int VALUE_THREE = 39;
    // 非编译常量
    private final int i4 = rand.nextInt(20);
    static final int INT_5 = rand.nextInt(20);

    private Value v1 = new Value(11);
    private final Value v2 = new Value(22);
    private static final Value v3 = new Value(33);

    private final int[] a = { 1, 2, 3, 4, 5, 6, };

    public String toString() {
        return id + &amp;quot;:&amp;quot; + &amp;quot;i4=&amp;quot; + i4 + &amp;quot;. INT_5=&amp;quot; + INT_5;
    }

    public static void main(String[] args) {
        House fd1 = new House(&amp;quot;fd1&amp;quot;);
        // ! fd1.valueOne++ // Error: 不能改变值
        fd1.v2.i++; // 对象不是常量
        fd1.v1 = new Value(9);
        // ! fd1.v2 = new Value(9); // Error: 对象为final
        for (int i = 0; i &amp;lt; fd1.a.length; i++) {
            fd1.a[i]++;// 数组对象也不是常量
        }
        // ! fd1.a = new int[3]; // Error: 数组对象为final
        System.out.println(fd1);
        System.out.println(&amp;quot;Create new data&amp;quot;);
        House fd2 = new House(&amp;quot;fd2&amp;quot;);
        System.out.println(fd1);
        System.out.println(fd2);
    }
} /* Output:
fd1:i4=15. INT_5=18
Create new data
fd1:i4=15. INT_5=18
fd2:i4=13. INT_5=18
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4，类的构造器调用遵循以下顺序&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;调用static初始化语句。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将要分配给对象的存储空间初始化成二进制零。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用基类构造器。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按声明顺序调用成员的初始化方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;调用导出类构造器的主体。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;inte&#34;&gt;接口&lt;/h2&gt;

&lt;p&gt;1, Java接口中的成员变量默认都是public static final类型的(都可省略)，必须被显示初始化，即接口中的成员变量为常量(大写，单词之间用&amp;rdquo;_&amp;ldquo;分隔)。Java接口中的方法默认都是public,abstract类型的(都可省略)，没有方法体，不能被实例化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface A {
    int CONST = 1; //合法,CONST默认为public,static,final类型
    void method(); //合法,method()默认为public,abstract类型
    public abstract void method2(); //method2()显示声明为public,abstract类型
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3, Java接口中只能包含public,static,final类型的成员变量和public,abstract类型的成员方法。接口中不能有构造方法，不能被实例化。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface A {
   int var; //错,var是常量,必须显示初始化
   public A(){...}; //错,接口中不能包含构造方法
   void method(){...};   //错,接口中只能包含抽象方法
   protected void method2(); //错,接口中的方法必须是public类型
   static void method3(){...};   //错,接口中不能包含静态方法
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;5, 一个接口不能实现(implements)另一个接口,但它可以继承多个其它的接口（多继承！！！）。&lt;/p&gt;

&lt;p&gt;6, 当类实现了某个Java接口时,它必须实现接口中的所有抽象方法,否则这个类必须声明为抽象的。&lt;/p&gt;

&lt;p&gt;8, 不允许创建接口的实例(实例化),但允许定义接口类型的引用变量,该引用变量引用实现了这个接口的类的实例（多态）。&lt;/p&gt;

&lt;p&gt;比较抽象类和接口：&lt;/p&gt;

&lt;p&gt;相同点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;都代表系统的抽象层,当一个系统使用一颗继承树上的类时,应该尽量把引用变量声明为继承树的上层抽象类型,这样可以提高两个系统之间的松耦合&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;都不能被实例化&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;都包含抽象方法,这些抽象方法用于描述系统能提供哪些服务,但不提供具体的实现&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;不同点&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;抽象类中可以对部分方法进行实现，而接口中全部是抽象方法。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;一个类只能继承一个父类（抽象类），却可以实现多个接口。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口可以继承多个接口，抽象类只能继承一个抽象类。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;接口中的变量默认都是public static final常量，方法都是public abstract。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;inne&#34;&gt;内部类&lt;/h2&gt;

&lt;p&gt;内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。所以内部类的成员变量/方法名可以和外部类的相同。&lt;/p&gt;

&lt;p&gt;1，内部类可以分为在类中的内部类（成员内部类和静态内部类）以及在方法中的内部类（局部内部类和&lt;strong&gt;匿名内部类&lt;/strong&gt;）。&lt;/p&gt;

&lt;p&gt;2，成员内部类和静态内部类都可以与外围类相互访问，即使是私有域，静态内部类只能访问其外围类的静态成员，除此之外与成员内部类没有任何区别。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 代码1：内部类对外部类可见
class Outer{
    //创建私有内部类对象
    public Inner in=new Inner();

    //私有内部类
    private class Inner{
         ...
    }
}

//代码2：外部类对内部类可见
//(内部类可以访问外部类的所有成员变量和方法)
class Outer{
    //外部类私有数据域
    private int data=0;

    //内部类
    class Inner{
        void print(){
            //内部类访问外部私有数据域
            System.out.println(data);
        }
    }
}

//代码3：静态内部类对外部变量的引用
public class Outer{
    private static int i=0;

    //创建静态内部类对象
    public Inner in=new Inner();

    //静态内部类
    private static class Inner{
        public void print(){
            System.out.println(i);   //如果i不是静态变量，这里将无法通过编译
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3，局部内部类没有访问修饰符，对包围它的方法之外的任何东西都不可见；局部内部类只能够访问该方法中的局部变量，且这些局部变量一定要是final修饰的常量。匿名内部类就是没有名字的局部内部类，它没有构造器，&lt;strong&gt;它隐式的继承了一个父类或者实现了一个接口&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Outter{
    public void outMethod(){
        final int beep=0;
        class Inner{
            //使用beep
        }

        Inner in=new Inner();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;coll&#34;&gt;容器类&lt;/h2&gt;

&lt;p&gt;1，数组（非容器）：将数字与对象联系起来，保存类型明确的对象，可以是多维的，但是数组一旦生成其大小不能改变。&lt;/p&gt;

&lt;p&gt;2，容器可以分为Collection和Map：Collection保存单一的元素，主要有List、Set等派生接口；Map则以名值对的方式存储。常用的容器有ArrayList/LinkedList、HashSet和HashMap。&lt;/p&gt;

&lt;p&gt;3，List的特点是有顺序而可以重复，Set的特点是无顺序而不可重复。重复不是指容器中装了两个相同的对象，而是他们的值相等，因此自定义对象作为容器的储存元素时，我们必须重写java.lang.Object的equals方法（同时也应重写hashCode方法），Object的默认equals只有当比较的参数是本身时才返回true。&lt;/p&gt;

&lt;p&gt;4，ArrayList实现了大小可变的数组，get/set方法均为线性时间，add/remove则比较费时；LinkedList可以快速的add/remove，但get/set方法比较慢。也因此LinkedList常被用作栈和队列使用。&lt;/p&gt;

&lt;p&gt;5，Set有两个派生接口HashSet和TreeSet。HashSet是为快速查找设计的Set，存入HashSet的对象必须定义hashCode()；Tree是保存次序的Set，底层为树结构，可以提取有序序列。LinkedHashSet派生自HashSet，具有HashSet的查询速度，同时维护了元素的插入顺序。&lt;/p&gt;

&lt;p&gt;6，Map有两个派生接口HashMap和TreeMap。 HashMap使用对象的hashCode()进行快速查询，TreeMap基于红黑树，维护了名值对的次序。LinkedHashMap派生自HashMap，维护了元素的顺序。&lt;/p&gt;

&lt;p&gt;7，一般情况下数据结构的选择：多查少改选ArrayList；多改少查选LinkedList；如果大量数据进行检索选Map。&lt;/p&gt;

&lt;p&gt;8，一些开销较大的同步接口：Vector(&amp;ndash;ArrayList)、HashTable(&amp;ndash;HashMap)、Stack(&amp;ndash;LinkedList)。&lt;/p&gt;

&lt;p&gt;9，java.util.Collection是一个集合接口，定义了一些集合基本操作的通用方法（add/remove）；java.util.Collections是一个包装类，定义了一些集合操作的静态多态方法（sort/shuffle/synchronizedXXX），类似一个工具类。另：Arrays工具类也提供了一些对数组的静态操作方法。&lt;/p&gt;

&lt;p&gt;10，Java集合中，判断两个对象是否相等的规则是：判断两个对象的hashCode是否相等，若不相等，则认为两个对象不相等，若hashCode相等则继续判断两个对象用equals运算是否相等，若相等则两个对象相等。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class HashTest {
    private int i;

    public int getI() {
        return i;
    }

    public void setI(int i) {
        this.i = i;
    }

    // 若没有重写equals方法，对象不相等
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }
        if (object == this) {
            return true;
        }
        if (!(object instanceof HashTest)) {
            return false;
        }
        HashTest other = (HashTest) object;
        if (other.getI() == this.getI()) {
            return true;
        }
        return false;

    // 若没有重写hashCode方法，对象不相等
    public int hashCode() {
        return i % 10;
    }

    public final static void main(String[] args) {
        HashTest a = new HashTest();
        HashTest b = new HashTest();
        a.setI(1);
        b.setI(1);
        Set&amp;lt;HashTest&amp;gt; set = new HashSet&amp;lt;HashTest&amp;gt;();
        set.add(a);
        set.add(b);
        System.out.println(a.hashCode() == b.hashCode());
        System.out.println(a.equals(b));
        System.out.println(set);
    }
} /* Output:
true
true
[com.allenyip.test.HashTest@1]
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;exce&#34;&gt;异常&lt;/h2&gt;

&lt;p&gt;1，Throwable类是所有异常类的基类，他有两个派生类Error和Exception：Error是程序无法处理的错误，如StackOverFlow/OutOfMemoryError等，此类错误通常交给JVM处理。Exception则是程序本身可以处理的异常。&lt;/p&gt;

&lt;p&gt;2，Exception又可以分为CheckedException和UncheckedException，其中UncheckedException（或叫RuntimeException）和Error一样是程序无法处理的，如ClassNotFoundException/IllegalArgumentException/NullPointerException/IndexOutOfBoundsException等。&lt;/p&gt;

&lt;p&gt;3，使用try&amp;hellip;catch&amp;hellip;finally使用异常，可以更好的处理程序：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;
public static void testException1() {
    int[] ints = new int[] { 1, 2, 3, 4 };
    System.out.println(&amp;quot;异常出现前&amp;quot;);
    try {
        System.out.println(ints[4]);
        System.out.println(&amp;quot;我还有幸执行到吗&amp;quot;);// 发生异常以后，后面的代码不能被执行
    } catch (IndexOutOfBoundsException e) {
        System.out.println(&amp;quot;数组越界错误&amp;quot;);
    }
    System.out.println(&amp;quot;异常出现后&amp;quot;);
} /*
异常出现前
数组越界错误
异常出现后
*/

public static void testException2() {
    int[] ints = new int[] { 1, 2, 3, 4 };
    System.out.println(&amp;quot;异常出现前&amp;quot;);
    System.out.println(ints[4]);
    System.out.println(&amp;quot;我还有幸执行到吗&amp;quot;);// 发生异常以后，他后面的代码不能被执行
} /*
异常出现前
Exception in thread &amp;quot;main&amp;quot; java.lang.ArrayIndexOutOfBoundsException: 4
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4，在catch语句块中可以使用throw语句重新抛出异常（方法中用throws声明抛出的异常），将异常抛出给上一个调用者；三个以上的异常链会丢失异常，使用x.initCause(xx);方法可以保存异常信息，使得在抛出另外一个异常的同时不丢失原来的异常。&lt;/p&gt;

&lt;p&gt;5，try&amp;hellip;catch&amp;hellip;finally细节&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;catch 块：用于处理try捕获到的异常。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。&lt;strong&gt;当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行&lt;/strong&gt;。在以下4种特殊情况下，finally块不会被执行：在finally语句块中发生了异常；在前面的代码中用了System.exit()退出程序；程序所在的线程死亡；关闭CPU。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;stri&#34;&gt;字符串&lt;/h2&gt;

&lt;p&gt;1，Java字符串类(java.lang.String)是Java中使用最多的类，也是最为特殊的一个类。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String类是final的，不可被继承。public final class String。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String类是的本质是字符数组char[], 并且其值不可改变。private final char value[];&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String类对象有个特殊的创建的方式，就是直接指定比如String x = &amp;ldquo;abc&amp;rdquo;，&amp;rdquo;abc&amp;rdquo;就表示一个字符串对象。而x是&amp;rdquo;abc&amp;rdquo;对象的地址，也叫做&amp;rdquo;abc&amp;rdquo;对象的引用。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String对象可以通过“+”串联。串联后会生成新的字符串。也可以通过concat()来串联。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;创建字符串的方式很多，归纳起来有三类：1）使用new关键字创建字符串，比如String s1 = new String(&amp;ldquo;abc&amp;rdquo;);2）直接指定。比如String s2 = &amp;ldquo;abc&amp;rdquo;;3）使用串联生成新的字符串。比如String s3 = &amp;ldquo;ab&amp;rdquo; + &amp;ldquo;c&amp;rdquo;;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java运行时会维护一个String Pool（String池），用来存放运行时中产生的各种字符串 ，并且池中的字符串的内容不重复。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;intern方法用于常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用， 如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class Test {
    public static void main(String[] args){
        String s0 = &amp;quot;allen&amp;quot;;
        String s1 = &amp;quot;allen&amp;quot;; // String也是对象，但与其他对象不同，字符串存在一个字符串池中。
        String s2 = &amp;quot;al&amp;quot; + &amp;quot;len&amp;quot;;
        System.out.println( s0 == s1 );
        System.out.println( s0 == s2 );

        String s3 = new String(&amp;quot;allen&amp;quot;); // 运行时才创建的对象
        System.out.println( s0 == s3 );

        String s4 = new String(&amp;quot;allen&amp;quot;);
        s4 = s4.intern();
        System.out.println( s0 == s4 );
    }
} /* Output:
true
true
false
true
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2，String对象的创建根据以下原理：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个X在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3，String类的主要用法：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;获取长度 str.length()。（数组是arr.length）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;比较字符串：s1.equals(s2)判断内容是否相同、s1.compareTo(s2)判断大小关系、==判断内容与地址是否相同、s1.reagionMatches(&amp;hellip;)判断部分相同&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找字符 s.charAt(index)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;查找字符串位置 s1.indexOf(s2)返回s1中第一次s2出现位置、s1.indexOf(s2, fromIndex)从字符串的第fromIndex个字符开始检索。（类似有lastIndexOf）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串包含 s1.conatins(s2)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;截取子串 s1.subString(beginIndex)/s1.subString(beginIndex, endIndex)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;字符串替换 replace(oldChar, newChar)、replaceAll(regex, replacement)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;去除首尾空格 s.trim()&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;转换成字符数组 s.toCharArray();&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;分割成字符串数组 s.split(regex);&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;4，String StringBuffer StrnigBuilder的区别&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;String是长度不可变的字符串常量(final类)，StringBuffer线程安全的长度可变的字符串变量，StrnigBuilder是非线程安全的长度可变的字符串变量。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;如果操作少量数据，使用String；单线程操作大量数据，使用StrnigBuidler；多线程操作大量数据，使用StringBuffer。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;String的“+”操作性能极差，若有大量此类操作则应考虑使用StringBuffer/StringBuilder。（实际上在JVM内部，String的+操作也会借助StringBuffer完成）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;使用StringBuffer/StringBuilder应尽可能指定其容量Capacity（默认16）。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;StringBuilder相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险，因此除非对性能要求很高，否则不建议使用。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;type&#34;&gt;类型信息&lt;/h2&gt;

&lt;p&gt;1，在java中，所有的类型转换都是在运行时进行正确性检查的。这也是RTTI/RunTime Type Information的含义：在运行时，识别一个对象的类型信息（如类名、继承的基类、实现的接口等）。传统的RTTI在&lt;strong&gt;编译时&lt;/strong&gt;已知道了所有类型；反射机制则在程序运行时发现和使用类型信息。&lt;/p&gt;

&lt;p&gt;2，Java使用一个Class对象来创建类的所有“常规”对象，以执行其RTTI。生成Class对象的过程如下：当我们编写一个新的java类时，JVM就会帮我们编译成class对象，存放在同名的.class文件中。在运行时，当需要生成这个类的对象，JVM就会检查此类是否已经装载内存中。若是没有装载，则把.class文件装入到内存中（RTTI从本地获取，反射从网络获取）。若是装载，则根据class文件生成实例对象。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;class Candy {
  static { System.out.println(&amp;quot;Loading Candy&amp;quot;); }
}

class Gum {
  static { System.out.println(&amp;quot;Loading Gum&amp;quot;); }
}

class Cookie {
  static { System.out.println(&amp;quot;Loading Cookie&amp;quot;); }
}

public class SweetShop {
  public static void main(String[] args) {
    System.out.println(&amp;quot;inside main&amp;quot;);
    new Candy();
    System.out.println(&amp;quot;After creating Candy&amp;quot;);
    try {
      Class.forName(&amp;quot;Gum&amp;quot;);
    } catch(ClassNotFoundException e) {
      System.out.println(&amp;quot;Couldn&#39;t find Gum&amp;quot;);
    }
    System.out.println(&amp;quot;After Class.forName(\&amp;quot;Gum\&amp;quot;)&amp;quot;);
    new Cookie();
    System.out.println(&amp;quot;After creating Cookie&amp;quot;);
  }
} /* Output:
inside main
Loading Candy
After creating Candy
Loading Gum
After Class.forName(&amp;quot;Gum&amp;quot;)
Loading Cookie
After creating Cookie
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3，获取Class实例有三种方式：利用对象调用getClass()方法；使用Class类的静态方法forName()，用类的名字获取一个Class实例；运用.class的方式来获取Class实例，对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的Class实例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class ClassTest {
    public static void main(String [] args)throws Exception{
        String str1=&amp;quot;abc&amp;quot;;
        Class cls1=str1.getClass();
        Class cls2=Class.forName(&amp;quot;java.lang.String&amp;quot;); // 必须是全名！
        Class cls3=String.class;
        System.out.println(cls1 == cls2);
        System.out.println(cls1 == cls3);
        Integer i = new Integer(1);
        System.out.println(i.TYPE);
    }
} /* Output:
true
true
int
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4，当不知道对象的类型而又需要构造对象时，可以使用newObj = oldObj.newInstance()方法，前提是这个类有默认的构造函数。该方法可能会产生InstantiationException和IllegalAccessException两种运行时异常。&lt;/p&gt;

&lt;p&gt;5，使用instanceOf/isInstance和Class的==/equals的区别是，前者判断的是该类或者该类的派生类，后者只判断是否为该类。&lt;/p&gt;

&lt;p&gt;6，代理分为静态代理和动态代理：静态代理由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了；动态代理在程序运行时，运用反射机制动态创建而成。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;//接口
interface Interface {
    void doSomething();
    void somethingElse(String arg);
}
//目标对象
class RealObject implement Interface {
    public void doSomething() {
        System.out.println(&amp;quot;RealObject doSomething&amp;quot;);
    }
    public void somethingElse(String arg) {
        System.out.println(&amp;quot;RealObject somethingElse&amp;quot; + arg);
    }
}
//简单代理对象
class SimpleProxy implements Interface {
    private Interface proxied;
    public SimpleProxy(Interface proxied) {
        this.proxied = proxied;
    }
    public void doSomething() {
        System.out.println(&amp;quot;SimpleProxy doSomething&amp;quot;);
        proxied.doSomething();
    }
    public void somethingElse(String arg) {
        System.out.println(&amp;quot;SimpleProxy somethingElse&amp;quot;+ arg);
        proxied.somethingElse(arg);
    }
}
Class SimpleProxyDemo {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse(&amp;quot;TestProxy&amp;quot;);
    }
    public static void main(String[] args) {
        //不用代理
        consumer(new RealObject());
        //使用代理
        consumer(new SimpleProxy(new RealObject()));
    }
}
 /* Output:
RealObject doSomething
RealObjectsomethingElse TestProxy
SimpleProxy doSomething
RealObject doSomething
SimpleProxy somethingElse TestProxy
RealObject somethingElse TestProxy
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;7，Java内部的动态代理是针对接口的动态代理（可以使用第三方的cglib实现对类的动态代理），它需要：&lt;strong&gt;实现InvocationHandler接口并且实现其invoke()方法&lt;/strong&gt;，该方法是代理调用目标对象方法以及提供额外操作的方法；&lt;strong&gt;使用Proxy.newProxyInstance(类加载器, 代理接口列表,InvocationHandler对象)方法创建实现了指定接口的动态代理&lt;/strong&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.reflect.*;
//接口
interface Interface {
    void doSomething();
    void somethingElse(String arg);
}
//目标对象
class RealObject implements Interface {
    public void doSomething() {
        System.out.println(&amp;quot;RealObject doSomething&amp;quot;);
    }
    public void somethingElse(String arg) {
        System.out.println(&amp;quot;RealObject somethingElse&amp;quot; + arg);
    }
}
//代理处理类
class DynamicProxyHandler implements InvocationHandler {
    private Object proxied;
    public DynamicProxyHandler(Object proxied){
        this.proxied = proxied;
    }
    //动态代理调用目标对象的方法
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
        System.out.println(&amp;quot;Dynamic proxy invoke&amp;quot;);
        return method.invoke(proxied, args);
    }
}
class SimpleDynamicProxy {
    public static void consumer(Interface iface){
        iface.doSomething();
        iface.somethingElse(&amp;quot;DynamicProxy&amp;quot;);
    }
    public static void main(String[] args){
        RealObject real = new RealObject();
        //不用代理
        consumer(real);
        //创建动态代理
        Interface proxy = (Interface) Proxy.newProxyInstance(
                        Interface.class.getClassLoader(),
                        new Class[]{Interface.class},
                        new DynamicProxyHandler(real)
        );
        consumer(proxy);
    }
} /* Output:
RealObject doSomething
RealObject somethingElseDynamicProxy
Dynamic proxy invoke
RealObject doSomething
Dynamic proxy invoke
RealObject somethingElseDynamicProxy
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;geri&#34;&gt;泛型&lt;/h2&gt;

&lt;p&gt;1，泛型是对Java语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。使用泛型的动机如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 不用泛型，需要强制转换类型，混乱麻烦且不安全
List myIntList = new LinkedList(); //1
myIntList.add(newInteger(0)); //2
Integer x = (Integer)myIntList.iterator().next(); //3

// 使用了泛型则安全简便
List&amp;lt;Integer&amp;gt; myIntList = newLinkedList&amp;lt;Integer&amp;gt;(); //1’
myIntList.add(newInteger(0)); //2’
Integerx = myIntList.iterator().next(); //3’
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2，可以泛型将其理解成编译器层次的概念，在编译后的Java字节代码中是不包含泛型信息的。在编译时会执行&lt;strong&gt;类型擦除&lt;/strong&gt;，即清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。（泛型中的所有动作都发生在边界处：对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型）&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public interface List&amp;lt;E&amp;gt; {
    void add(E x);
    Iterator&amp;lt;E&amp;gt; iterator();
}
// 转换后的接口可以理解成：
public interface IntegerList {
    void add(Integer x)
    Iterator&amp;lt;Integer&amp;gt; iterator();
}
/* 重载时会导致编译时错误
 * List&amp;lt;String&amp;gt;和List&amp;lt;Integer&amp;gt;在运行时是相同类型，都被擦除成原生类型List
 */
public class Erasure{
    public void test(List&amp;lt;String&amp;gt; ls){
        System.out.println(&amp;quot;Sting&amp;quot;);
    }
    public void test(List&amp;lt;Integer&amp;gt; li){
        System.out.println(&amp;quot;Integer&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3，如果Foo是Bar的子类型，G是一种带泛型的类型，则G&lt;Foo&gt;不是G&lt;Bar&gt;的子类型。&lt;/p&gt;

&lt;p&gt;4，通配符“?”指定可以使用任何类型的集合作为参数，表示类型未知，因此也无法添加除null意外的元素。使用通配符的规则如下：如果你想从一个数据类型里获取数据，使用 ? extends 通配符；如果你想把对象写入一个数据结构里，使用 ? super 通配符；如果你既想存，又想取，那就别用通配符。&lt;/p&gt;

&lt;p&gt;5，使用泛型方法时，类型T应该位于返回值之前。关于泛型的一些种类，见&lt;a href=&#34;http://www.cnblogs.com/sunwei2012/archive/2010/10/08/1845938.html。&#34; rel=&#34;nofollow noreferrer&#34; target=&#34;_blank&#34;&gt;http://www.cnblogs.com/sunwei2012/archive/2010/10/08/1845938.html。&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;static void fromArrayToCollection(Object[]a, Collection&amp;lt; ?&amp;gt; c) {
    for (Object o:a) {
    c.add(o); //compile time error
    }
}
static &amp;lt;T&amp;gt; void fromArrayToCollection(T[] a, Collection&amp;lt;T&amp;gt;c){
    for(T o : a) {
        c.add(o);// correct
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;enum&#34;&gt;枚举&lt;/h2&gt;

&lt;p&gt;关于枚举的七个用法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. 常量
public enum Color {
  RED, GREEN, BLANK, YELLOW
}

// 2. switch
enum Signal {
    GREEN, YELLOW, RED
}
public class TrafficLight {
    Signal color = Signal.RED;
    public void change() {
        switch (color) {
        case RED:
            color = Signal.GREEN;
            break;
        case YELLOW:
            color = Signal.RED;
            break;
        case GREEN:
            color = Signal.YELLOW;
            break;
        }
    }
}

// 3. 向枚举中添加新方法
// 必须在enum实例序列的最后添加一个分号
// 必须先定义 enum 实例
public enum Color {
    RED(&amp;quot;红色&amp;quot;, 1), GREEN(&amp;quot;绿色&amp;quot;, 2), BLANK(&amp;quot;白色&amp;quot;, 3), YELLO(&amp;quot;黄色&amp;quot;, 4);
    // 成员变量
    private String name;
    private int index;
    // 构造方法
    private Color(String name, int index) {
        this.name = name;
        this.index = index;
    }
    // 普通方法
    public static String getName(int index) {
        for (Color c : Color.values()) {
            if (c.getIndex() == index) {
                return c.name;
            }
        }
        return null;
    }
    // get set 方法
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getIndex() {
        return index;
    }
    public void setIndex(int index) {
        this.index = index;
    }
}

// 4. 覆盖枚举的方法
public enum Color {
    RED(&amp;quot;红色&amp;quot;, 1), GREEN(&amp;quot;绿色&amp;quot;, 2), BLANK(&amp;quot;白色&amp;quot;, 3), YELLO(&amp;quot;黄色&amp;quot;, 4);
    // 成员变量
    private String name;
    private int index;
    // 构造方法
    private Color(String name, int index) {
        this.name = name;
        this.index = index;
    }
    //覆盖方法
    @Override
    public String toString() {
        return this.index+&amp;quot;_&amp;quot;+this.name;
    }
}

// 5. 实现接口
public interface Behaviour {
    void print();
    String getInfo();
}
public enum Color implements Behaviour{
    RED(&amp;quot;红色&amp;quot;, 1), GREEN(&amp;quot;绿色&amp;quot;, 2), BLANK(&amp;quot;白色&amp;quot;, 3), YELLO(&amp;quot;黄色&amp;quot;, 4);
    // 成员变量
    private String name;
    private int index;
    // 构造方法
    private Color(String name, int index) {
        this.name = name;
        this.index = index;
    }
//接口方法
    @Override
    public String getInfo() {
        return this.name;
    }
    //接口方法
    @Override
    public void print() {
        System.out.println(this.index+&amp;quot;:&amp;quot;+this.name);
    }
}

// 6. 使用接口组织枚举
public interface Food {
    enum Coffee implements Food{
        BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO
    }
    enum Dessert implements Food{
        FRUIT, CAKE, GELATO
    }
}

// 7. 枚举集合java.util.EnumSet和java.util.EnumMap
// EnumSet保证集合中的元素不重复
// EnumMap中的key是enum类型，而value则可以是任意类型
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arra&#34;&gt;数组&lt;/h2&gt;

&lt;p&gt;关于数组的十二个最佳方法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 1. 声明一个数组有三种方式
int[] a = new int[3]; // 必须指定其大小 同int a[]
int[] b = { 1, 2, 3 }; // 同 { 1, 2, 3, }
int[] c = new int[]{ 1, 2, 3 }; // new后的[]由{}个数决定大小

// 2. 输出一个数组
int[] intArray = { 1, 2, 3 };
String intArrayString = Arrays.toString(intArray);
System.out.println(intArray);  // [I@7150bd4d
System.out.println(intArrayString); // [1, 2, 3]
// 也可通过循环输出，效率没有Arrays.toString高

// 3. 从一个数组创建数组列表
String[] stringArray = { &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot; };
ArrayList&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;String&amp;gt;(Arrays.asList(stringArray));
System.out.println(arrayList);// [a, b, c, d, e]

// 4. 检查一个数组是否包含某个值
String[] stringArray = { &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot; };
boolean b = Arrays.asList(stringArray).contains(&amp;quot;a&amp;quot;);

// 5. 连接两个数组
int[] intArray = { 1, 2, 3, 4, 5 };
int[] intArray2 = { 6, 7, 8, 9, 10 };
// Apache Commons Lang library
int[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);

// 6. 声明一个内联数组（Array inline）
method(new String[]{&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot;});

// 7. 把提供的数组元素放入一个字符串
// containing the provided list of elements
// Apache common lang
String j = StringUtils.join(new String[] { &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot; }, &amp;quot;, &amp;quot;);
System.out.println(j);// a, b, c

// 8. 将一个数组列表转换为数组
String[] stringArray = { &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;, &amp;quot;d&amp;quot;, &amp;quot;e&amp;quot; };
ArrayList&amp;lt;String&amp;gt; arrayList = new ArrayList&amp;lt;String&amp;gt;(Arrays.asList(stringArray));
String[] stringArr = new String[arrayList.size()];
arrayList.toArray(stringArr);
for (String s : stringArr)
    System.out.println(s);

// 9. 将一个数组转换为集（set）
Set&amp;lt;String&amp;gt; set = new HashSet&amp;lt;String&amp;gt;(Arrays.asList(stringArray));
System.out.println(set);//[d, e, b, c, a]

// 10. 逆向一个数组
int[] intArray = { 1, 2, 3, 4, 5 };
ArrayUtils.reverse(intArray);
System.out.println(Arrays.toString(intArray));//[5, 4, 3, 2, 1]

// 11. 移除数组中的元素
int[] intArray = { 1, 2, 3, 4, 5 };
int[] removed = ArrayUtils.removeElement(intArray, 3);//create a new array
System.out.println(Arrays.toString(removed));

// 12. 将整数转换为字节数组
byte[] bytes = ByteBuffer.allocate(4).putInt(8).array();
for (byte t : bytes) {
   System.out.format(&amp;quot;0x%x &amp;quot;, t);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;anno&#34;&gt;注解&lt;/h2&gt;

&lt;p&gt;1，内置的三个注解：@Override只能用在方法之上的，用来告诉别人这一个方法是改写父类的、@Deprecated建议别人不要使用旧的API，编译的时候会用产生警告信息、@SuppressWarnings可以暂时关闭警告信息。&lt;/p&gt;

&lt;p&gt;2，自定义注解时，需要使用到四个元注解（即注解的注解）：@Retention定义注解的保留策略、@Target定义注解的作用目标、@Document说明该注解将被包含在javadoc中、@Inherited说明子类可以继承父类中的该注解。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.lang.annotation.*;
@Documented // 此注解会包含在javadoc中
@Target(ElementType.METHOD) // 用于方法
@Retention(RetentionPolicy.CLASS) // 默认，注解会在class字节码文件中存在，但运行时无法获得
public @interface Test {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;io&#34;&gt;Java I/O&lt;/h2&gt;

&lt;p&gt;1，Java中把不同的数据源与程序间的数据传输都抽象表述为&amp;rdquo;流&amp;rdquo;(Stream),java.io包中定义了多种I/O流类型实现数据I/O功能。I/O流可以分为输入流(Input Stream)和输出流(Output Stream)、节点流(Node Stream)和处理流(Processing Stream)、字符流(Character Stream)和字节流(Byte Stream)。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;按照数据流动的方向，java流可分为输入流(Input Stream)和输出流(Output Stream)。输入流只能从中读取数据，而不能向其写出数据；输出流则只能向其写出数据,而不能从中读取数据。（除java.io.RandomAccessFile类外）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;根据数据流所关联的是数据源还是其他数据流,可分为节点流(Node Stream)和处理流(Processing Stream)。节点流直接连接到数据源；处理流是对一个已存在的流的连接和封装，通过封装的流的功能调用实现增强的数据读/写功能，处理流并不直接连接到数据源。（处理流无法直接操作文件，应基于节点流封装）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;按传输数据的&amp;rdquo;颗粒大小&amp;rdquo;划分，可分为字符流(Character Stream)和字节流(Byte Stream)。字节流以字节为单位进行数据传输，每次传送一个或多个字节；字符流以字符为单位进行数据传输，每次传送一个或多个字符。Java命名惯例:
凡是以InputStream或OutputStream结尾的类型均为字节流，凡是以Reader或Writer结尾的均为字符流。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;2，Java I/O包括以下三个层次：&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;InputStream（二进制格式输入操作）和OuputStream（二进制格式输出操作）两个抽象类，是所有输入/输出流的父类，定义了所有输入/输出流都具有的共同特征。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Reader（文件格式输入操作）和Writer（文件格式输出操作）两个抽象类，是基于字符的操作。由于Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;RandomAccessFile（随机文件操作）：功能丰富，可以从文件的任意位置进行存取（输入输出）操作。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;3，常用的Java I/O流类型&lt;/p&gt;

&lt;p&gt;1）使用FileInputStream/FileOutputStream字节流实现文件的复制：FileInputStream用于读取本地文件中字节数据，FileOutputStram用于将字节数据写到文件&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
public class CopyFile{
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream (&amp;quot;a.jpg&amp;quot;);
            FileOutputStream fos = new FileOutputStream (&amp;quot;temp.jpg&amp;quot;);
            int read = fis.read();
            while ( read != -1 ) {
                fos.write(read);
                read = fis.read();
            }
            fis.close();
            fos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2）使用FileReader/FileWriter字符流实现文件的复制：FileReader用于以字符为单位读取文本文件，FileWriter类用于将字符数据写到文本文件中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
public class Test {
    public static void main(String[] args) {
        try {
            FileReader input = new FileReader(&amp;quot;a.txt&amp;quot;);
            FileWriter output = new FileWriter(&amp;quot;temp.txt&amp;quot;);
            int read = input.read();
            while ( read != -1 ) {
                output.write(read);
                read = input.read();
            }
            input.close();
            output.close();
        } catch (IOException e) {
            System.out.println(e);
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3）使用BufferedReader/BufferedWriter字符处理流实现文件的复制：BufferedReader用于缓冲读取字符，BufferedWriter则是供字符的缓存写出功能。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;import java.io.*;
public class Test {
    public static void main(String[] args) {
        try {
            FileReader input = new FileReader(&amp;quot;Test.java&amp;quot;);
            BufferedReader br = new BufferedReader(input);
            FileWriter output = new FileWriter(&amp;quot;temp.txt&amp;quot;);
            BufferedWriter bw = new BufferedWriter(output);
            String s = br.readLine();
            while ( s!=null ) {
                bw.write(s);
                bw.newLine();
                s = br.readLine();
            }
            br.close();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;4）InputStreamReader封装字节输入流并从中读取字节数据,然后将之转换为字符，OutputStreamWriter按照特定的字符编码规则把字符转化为字节并写出到它所封装的字节输出流。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;FileInputStream fis = new FileInputStream(&amp;quot;a.txt&amp;quot;);
InputStreamReader isr = new InputStreamReader(fis);

FileOutputStream fos = new FileOutputStream(&amp;quot;b.txt&amp;quot;);
OutputStreamWriter osw = new OutputStreamWriter(fos);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conc&#34;&gt;并发&lt;/h2&gt;

&lt;p&gt;并发编程可以将程序划分为多个分离的、独立的任务，这些任务通过多线程机制分别由一个与之对应的线程驱动。&lt;/p&gt;

&lt;p&gt;1，通过实现Runnable接口并重写其run()方法来定义一个任务：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class LiftOff implements Runnable {
    protected int countDown = 10;
    private static int taskCount = 0;
    private final int id = taskCount++;

    public LiftOff() { }

    public LiftOff(int countDown) {
        this.countDown = countDown;
    }

    public String status() {
        return &amp;quot;#&amp;quot; + id + &amp;quot;(&amp;quot; + (countDown &amp;gt; 0 ? countDown : &amp;quot;Liftoff!&amp;quot;) + &amp;quot;),&amp;quot;;
    }

    @Override
    public void run() {
        while (countDown-- &amp;gt; 0) {
            System.out.println(status());
            Thread.yield(); // 该方法“建议”线程调度器进行任务切换
        }
    }
}
public class Test {
    public static void main(String[] args) {
        LiftOff launch = new LiftOff();
        launch.run(); // 并没有启动一个新线程，而是使用main线程
    }
} /* Output:
#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(Liftoff!)
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2，将Runnable对象转变为工作任务的传统方式是把它交给Thread构造器：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class BasicThreads {
    public static void main(String[] args) {
        Thread t = new Thread(new LiftOff());
        t.start(); // 启动了新线程
        System.out.println(&amp;quot;Waiting for LiftOff&amp;quot;);
    }
} /* Output:
Waiting for LiftOff
#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(Liftoff!)
*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thread类的start方法启动线程，先执行一些必须的初始化操作，后调用Runnable的run方法。此时main线程和LiftOff.run()两个线程同时执行。&lt;/p&gt;

&lt;p&gt;3，java.util.concurrent.Executor用于管理Thread对象，从而简化并发编程。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;public class CashedThreadPool {
    public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i = 0; i &amp;lt; 5; i++) {
            exec.execute(new LiftOff());
        }
        exec.shutdown();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以通过ExecutorService exec = Executors.newFixedThreadPool(5);来限定有限的线程集执行所提交的任务。&lt;/p&gt;

&lt;p&gt;4，Runnable是执行工作的独立任务，它不返回任何值，若需要返回则应实现具有类型参数泛型的Callable接口。&lt;/p&gt;

&lt;p&gt;5，sleep()方法使人物中止执行给定的时间，称为休眠。调用sleep()方法可以抛出InterruptedException异常。&lt;/p&gt;

&lt;p&gt;6，可以通过Thread.currentThread()获取当前线程的对象。&lt;/p&gt;

&lt;p&gt;7，可以通过setPriority(aIntPriority)设置线程的优先级，调度器倾向于先运行优先级高的线程但不一定，一般只使用MAX_PRIORITY/NORMAL_PRIORITY/MIN_PRIORITY三个优先级。&lt;/p&gt;

&lt;p&gt;8，后台/daemon线程是指程序运行时在后台提供一种通用服务的线程，并且这种线程不是程序不可或缺的。因此当所有非后台线程结束时，程序终止，同时杀死进程中所有的后台线程；通过setDaemon()方法将一个线程设置成后台线程，通过isDaemon()方法判断一个线程是否后台线程。（后台线程创建的线程自动设置为后台线程）&lt;/p&gt;

&lt;p&gt;9，还可以通过直接继承Thread类来实现线程，Thread类本身不执行任何操作，它只是驱动赋予它的任务。&lt;/p&gt;

&lt;p&gt;10，线程具有开始（等待）、运行、挂起和停止四种不同的状态：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-java&#34;&gt;// 开始线程
public void start( );
public void run( );

// 挂起和唤醒线程
public void resume( );     // 不建议使用
public void suspend( );    // 不建议使用
public static void sleep(long millis);
public static void sleep(long millis, int nanos);

// 终止线程
public void stop( );       // 不建议使用
public void interrupt( );

// 得到线程状态
public boolean isAlive( );
public boolean isInterrupted( );
public static boolean interrupted( );

// join方法
public void join( ) throws InterruptedException;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;TODO: 资源共享、线程写作、死锁..&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>