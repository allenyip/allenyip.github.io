<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Allen Yip">
  
  
  
  
  <link rel="next" href="https://allenyip.github.io/2013/the-it-crowd/" />
  <link rel="canonical" href="https://allenyip.github.io/2013/java-basic/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Java基础 | Allen Yip
       
  </title>
  <meta name="title" content="Java基础 | Allen Yip">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/allenyip.github.io\/"
    },
    "articleSection" : "posts",
    "name" : "Java基础",
    "headline" : "Java基础",
    "description" : "基本数据结构 操作符 控制执行流程 初始化与清理 访问权限控制 复用类 接口 内部类 容器类 异常 字符串 类型信息 泛型 枚举 数组 注解 Java I\/0 并发  基本数据类型 1，Java里的数据类型分为基本类型和引用类型。基本类型可直接创建赋值并存储于栈中，引用类型或通过new关键字创建并存储于堆中，或直接存储于String常量池中。\n Java有六个地方可以存储数据，按照存取速度排列：\n 寄存器Register：位于处理器内部，由编译器分配，无法控制\n 栈Stack：存放基本类型的数据和对象\/数组的引用，但对象本身不存在栈中，而存在堆中（new出来的对象）或者字符串常量池中\n 堆Heap：堆比栈更加灵活，无需知道分配了多少空间，也无需知道对象存活多长时间。\n 静态存储：存放程序运行时一直存在的数据\n 常量存储：直接存放在程序代码内部，存放字符串常量和基本类型常量（public static final）\n 非RAM存储：如硬盘等永久存储空间，完全存活于程序之外，不受程序的任何控制。\n  注：对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。\n注2：对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。\n String s = new String(“xyz”);产生几个对象？如果常量池中有xyz则只在堆中产生一个拷贝对象（一个）；如果常量池中没有xyz，则在常量池中创建xyz，然后在堆中创建拷贝（两个）。\n2，由于JVM是独立于底层的机器，基本数据类型大小是固定的，因此Java也不需要sizeof操作。基本数据类型及其大小如下所示：\n boolean，-，大小未明确定义，仅定义为字面值true\/false，默认值false。\n char，16位，默认值\\u0000(null)。\n byte，8位，默认值(byte)0。\n short，16位，默认值(short)0。所有数值类型都有正负号！\n int，32位，默认值0。\n long，64位，默认值0L。\n float，32位，默认值0.0f。\n double，64位，默认值0.0d。\n void，-\n  基本类型在作为类的成员时会被赋予默认值，即使未进行初始化也能运行；而作为局部变量，如位于方法中而不是类中，其默认值可能是任意的，并且在运行时会报错。（类变量同理，默认赋予null值）",
    "inLanguage" : "en-us",
    "author" : "Allen Yip",
    "creator" : "Allen Yip",
    "publisher": "Allen Yip",
    "accountablePerson" : "Allen Yip",
    "copyrightHolder" : "Allen Yip",
    "copyrightYear" : "2013",
    "datePublished": "2013-03-15 00:00:00 \x2b0000 UTC",
    "dateModified" : "2013-03-15 00:00:00 \x2b0000 UTC",
    "url" : "https:\/\/allenyip.github.io\/2013\/java-basic\/",
    "wordCount" : "2952",
    "keywords" : [ "development","java", "Allen Yip"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://allenyip.github.io/">Allen Yip</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="About">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://allenyip.github.io/">Allen Yip</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="About">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Java基础</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://allenyip.github.io/" rel="author">Allen Yip</a> with ♥ 
                <span class="post-time">
                on <time datetime=2013-03-15 itemprop="datePublished">March 15, 2013</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://allenyip.github.io/categories/development/"> Development </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <ul>
<li><a href="#data">基本数据结构</a></li>
<li><a href="#oper">操作符</a></li>
<li><a href="#flow">控制执行流程</a></li>
<li><a href="#init">初始化与清理</a></li>
<li><a href="#acce">访问权限控制</a></li>
<li><a href="#reus">复用类</a></li>
<li><a href="#inte">接口</a></li>
<li><a href="#inne">内部类</a></li>
<li><a href="#coll">容器类</a></li>
<li><a href="#exce">异常</a></li>
<li><a href="#stri">字符串</a></li>
<li><a href="#type">类型信息</a></li>
<li><a href="#geri">泛型</a></li>
<li><a href="#enum">枚举</a></li>
<li><a href="#arra">数组</a></li>
<li><a href="#anno">注解</a></li>
<li><a href="#io">Java I/0</a></li>
<li><a href="#conc">并发</a></li>
</ul>

<h2 id="data">基本数据类型</h2>

<p>1，Java里的数据类型分为基本类型和引用类型。基本类型可直接创建赋值并存储于<strong>栈</strong>中，引用类型或通过new关键字创建并存储于<strong>堆</strong>中，或直接存储于String常量池中。</p>

<blockquote>
<p>Java有六个地方可以存储数据，按照存取速度排列：</p>

<ol>
<li><p>寄存器Register：位于处理器内部，由编译器分配，无法控制</p></li>

<li><p>栈Stack：存放基本类型的数据和对象/数组的引用，但对象本身不存在栈中，而存在堆中（new出来的对象）或者字符串常量池中</p></li>

<li><p>堆Heap：堆比栈更加灵活，无需知道分配了多少空间，也无需知道对象存活多长时间。</p></li>

<li><p>静态存储：存放程序运行时一直存在的数据</p></li>

<li><p>常量存储：直接存放在程序代码内部，存放字符串常量和基本类型常量（public static final）</p></li>

<li><p>非RAM存储：如硬盘等永久存储空间，完全存活于程序之外，不受程序的任何控制。</p></li>
</ol>

<p>注：对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期是可以确定的，当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。</p>

<p>注2：对于字符串：其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。</p>
</blockquote>

<p>String s = new String(“xyz”);产生几个对象？如果常量池中有xyz则只在堆中产生一个拷贝对象（一个）；如果常量池中没有xyz，则在常量池中创建xyz，然后在堆中创建拷贝（两个）。</p>

<p>2，由于JVM是独立于底层的机器，基本数据类型大小是固定的，因此Java也不需要sizeof操作。基本数据类型及其大小如下所示：</p>

<ul>
<li><p>boolean，-，大小未明确定义，仅定义为字面值true/false，默认值false。</p></li>

<li><p>char，16位，默认值\u0000(null)。</p></li>

<li><p>byte，8位，默认值(byte)0。</p></li>

<li><p>short，16位，默认值(short)0。所有数值类型都有正负号！</p></li>

<li><p>int，32位，默认值0。</p></li>

<li><p>long，64位，默认值0L。</p></li>

<li><p>float，32位，默认值0.0f。</p></li>

<li><p>double，64位，默认值0.0d。</p></li>

<li><p>void，-</p></li>
</ul>

<p><strong>基本类型在作为类的成员时会被赋予默认值，即使未进行初始化也能运行；而作为局部变量，如位于方法中而不是类中，其默认值可能是任意的，并且在运行时会报错。（类变量同理，默认赋予null值）</strong></p>

<p>3，除了继承自C++的单行注释//和多行注释/* * /，Java提供了文档注释/** * /，方便开发人员生成代码文档，注释文档分为类、域和方法三种，只能对public和protected成员进行注释。有两种使用方式：嵌入式HTML和文档标签（@开头）。一个示例如下：</p>

<pre><code class="language-java">import java.util.*;

/** The first Java example
 *  Display today's date
 *  @author Allen Yip
 *  @version 1.0
 */
public class HelloDate {
    /** Entrv point to application
     *  @param args array of arguments
     */
    public static void main(String[] args) {
        System.out.println(new Date());
    }
}
</code></pre>

<h2 id="oper">操作符</h2>

<p>1，赋值时，基本数据类型会直接将值复制，而类（对象）则只赋值引用，示例如下：</p>

<pre><code class="language-java">class Tank {
    int level;
}

public class Test {
    public static void main(String[] args) {
        Tank t1 = new Tank();
        Tank t2 = new Tank();
        t1.level = 1;
        t2.level = 2;
        System.out.println(&quot;1. t1.level=&quot; + t1.level + &quot; t2.level=&quot; + t2.level);
        t1 = t2; // 使用 t1.level = t2.level 来避免别名现象
        System.out.println(&quot;2. t1.level=&quot; + t1.level + &quot; t2.level=&quot; + t2.level);
        t1.level = 99;
        System.out.println(&quot;3. t1.level=&quot; + t1.level + &quot; t2.level=&quot; + t2.level);
    }
} /* Output:
1: t1.level=1 t2.level=2
2: t1.level=2 t2.level=2
3: t1.level=99 t2.level=99
*/
</code></pre>

<p>2，关系操作符 == 和 != 经常会令人迷惑：</p>

<p>对于基本类型，==是比较它们的值是否相等；对于复杂类型，==则是比较它们在内存的存放地址是否相等（即两个引用是否指向同一对象），若要比较值需要重写equals方法（以及hashCode方法）。</p>

<pre><code class="language-java">
class Value {
    int i;
}
public class Test {
    public static void main(String[] args) {
        int a1 = 47, a2 = 47;
        Integer b1 = new Integer(47);
        Integer b2 = new Integer(47);
        System.out.println(a1 == a2);
        System.out.println(b1 == b2);
        System.out.println(b1.equals(b2));

        // 自定义类
        Value v1 = new Value();
        v1.i = 47;
        Value v2 = new Value();
        v2.i = 47;
        System.out.println(v1.equals(v2));// 未覆盖equals方法
    }
} /* Output:
true
false
true
false
*/
</code></pre>

<p>3，移位操作符中，左移&lt;&lt;在低位补0；有符号右移&gt;&gt;使用符号扩展：符号位正则高位补0，为负则高位补1；Java增加了无符号右移&gt;&gt;&gt;操作，使用零扩展：无论正负高位都补0。</p>

<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        int i = -1;
        System.out.println(Integer.toBinaryString(i));
        i &gt;&gt;&gt;= 10;
        System.out.println(Integer.toBinaryString(i));
    }
} /* Output:
11111111111111111111111111111111
1111111111111111111111
*/
</code></pre>

<p>4，Java中对于boolean类型支持的操作只有：赋予true/false值、测试其真假。除此之外，对其加减等其他任何运算都会报错。除了boolean类型外的其他基本类型都可通过类型转换转变为其他基本类型，转换过程中必须留意“窄化转换”结果，否则可能会出现编译器无法预知的严重错误。</p>

<h2 id="flow">控制执行流程</h2>

<p>以下例子展示了break和continue的区别：</p>

<pre><code class="language-java">public class Test {
    public static void main(String[] args) {
        for (int i = 0; i &lt; 100; i++) {
            if (i == 74) break; // out of loop
            if (i % 9 != 0) continue; // next iteration
            System.out.println(i + &quot;&quot;);
        }
    }
} /* Output:
0 9 18 27 36 45 54 63 72
*/
</code></pre>

<p>5，除了单目运算符（! ~ ++ &ndash; +(单操作符) -(单操作符)）、条件运算符（? :）和赋值运算符（= += -= *= /= %= ^= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;=）是从右到左的顺序，其余运算都是从左往右。</p>

<h2 id="init">初始化与清理</h2>

<p>Java尽力保证所有变量在使用前都能得到初始化，默认构造器（无参构造器）在未显示定义构造器时会自动创建，若已定义则不会自动创建。方法重载根据参数类型列表，而非返回值（会产生歧义）。<strong>变量定义的先后顺序决定了它的初始化顺序，即使变量定义散布于方法定义之间，它们仍旧会在任何方法之前（包括构造器方法）被初始化</strong>。例子如下：</p>

<pre><code class="language-java">class Window {
    Window(int marker) {
        System.out.println(&quot;Window(&quot; + marker + &quot;)&quot;);
    }
}
class House {
    Window w1 = new Window(1); // before constructor
    House() {
        System.out.println(&quot;House()&quot;);
        w3 = new Window(33);
    }
    Window w2 = new Window(2); // after constructor
    void f() { System.out.println(&quot;f()&quot;);}
    Window w3 = new Window(3);
}
public class Test {
    public static void main(String[] args) {
        House h = new House();
        h.f();
    }
} /* Output:
Window(1)
Window(2)
Window(3)
House()
Window(33)
f()
*/
</code></pre>

<p>对象初始化流程如下：</p>

<ol>
<li><p>对象在初始化过程，JVM会先去搜索该类的顶级父类，直到搜索到继承树上的Object类</p></li>

<li><p>然后JVM按照继承树往下搜索，继续加载该类的子类，按照静态成员函数-&gt;静态成员变量-&gt;静态初始化块的顺序往下递归，直到加载完我们使用的对象所在的类</p></li>

<li><p>类加载完了过后开始对类进行实例化操作，这个过程还是会先搜索到Object类</p></li>

<li><p>之后，JVM会递归往继承树下边进行调用，按照成员函数-&gt;成员变量-&gt;构造函数的顺序，实例化该类的成员函数，然后实例化成员变量，执行构造函数</p></li>
</ol>

<ul>
<li>5. 最后直到最终类的构造函数调用完成</li>
</ul>

<h2 id="acce">访问权限控制</h2>

<p>Java中的访问权限控制等级从大到小依次为：public、protected、包访问权限（没有关键词/可表示为friendly、默认）和private。</p>

<p>当编译一个.java源文件时（此文件被称为编译单元），文件可以有一个public类并且该类名与文件名相同（最多只能有一个public），若该编译单元内还有其他类，这些类在包之外的世界是不可见的。</p>

<p>Java解释器的运行过程如下：</p>

<ol>
<li><p>找出环境变量CLASSPATH，CLASSPATH包括一个或多个目录，用于查找.class文件的根目录。</p></li>

<li><p>从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，产生一个路径。</p></li>

<li><p>将路径与CLASSPATH链接即为所要查找的.class文件路径。</p></li>
</ol>

<p>类的访问权限总是public或包访问权限（内部类除外），如果不希望该类被访问可以把所有构造器都指定为private，此时，除了通过类内部的static成员，其他类无法直接访问该类。</p>

<h2 id="reus">复用类</h2>

<p>1，使用组合或者继承来复用类，组合是将对象引用置于新类中，继承则是面向对象的四大特性之一，优先使用组合，如果需要向上转型（派生类可以替换基类）则使用继承。</p>

<p>实际项目中常常会结合使用组合和继承：</p>

<pre><code class="language-java">class Plate {
    Plate(int i) {
        System.out.println(&quot;Plate constructor&quot;);
    }
}

class DinnerPlate extends Plate {
    DinnerPlate(int i) {
        super(i);
        System.out.println(&quot;DinnerPlate constructor&quot;);
    }
}

class Utensil {
    Utensil(int i) {
        System.out.println(&quot;Utensil constructor&quot;);
    }
}

class Spoon extends Utensil {
    Spoon(int i) {
        super(i);
        System.out.println(&quot;Spoon constructor&quot;);
    }
}

class Fork extends Utensil {
    Fork(int i) {
        super(i);
        System.out.println(&quot;Fork constructor&quot;);
    }
}

class Custom {
    Custom(int i) {
        System.out.println(&quot;Custom constructor&quot;);
    }
}

public class PlaceSetting externds Custom {
    private Spoon sp;
    private Fork fk;
    private DinnerPlate pl;
    public PlaceSetting(int i) {
        super(i + 1);
        sp = new Spoon(i + 2);
        fk = new Fork(i + 3);
        pl = new DinnerPlate(i + 4);
        System.out.println(&quot;PlaceSetting constructor&quot;);
    }
    public static void main(String[] args) {
        PlaceSetting x = new PlaceSetting(9);
    }
} /* Output:
Custom constructor
Utensil constructor
Spoon constructor
Utensil constructor
Fork constructor
Plate constructor
DinnerPlate constructor
PlaceSetting constructor
*/
</code></pre>

<p>2，static关键字可以将对象固定在一个存储空间，可以满足两种需要：只想为某特定域分配单一存储空间；希望某个方法不与包含它的类的任何对象关联。static修饰的变量或方法与类打交道，类无需实例化；非static变量或方法则与对象打交道。</p>

<pre><code class="language-java">class Value1 {
    int x = 1;
    Integer i = new Integer(47);
}

class Value2 {
    static Integer i = new Integer(47);
}

public class House {
    public static void main(String[] args) {
        Value1 a1 = new Value1();
        Value1 a2 = new Value1();
        System.out.println(a1.x == a2.x);
        System.out.println(a1.i == a2.i);
        Value2 b1 = new Value2();
        Value2 b2 = new Value2();
        System.out.println(b1.i == b2.i);
    }
} /* Output:
true
false
true
*/
</code></pre>

<p>3，使用final关键字分为三种情况：数据、方法和类。</p>

<p>final成员变量表示常量，只能在定义处（只定义未赋值成为空白final）或者构造函数中赋值赋一次值，并且赋值后值不再改变。当final修饰参数时表示参数无法被更改。</p>

<p>使用final方法的原因是为了锁定方法防止被任何继承类修改，类中所有的private方法默认都是final的。</p>

<p>当某个类定义为final时，它无法被继承，亦即final类中所有的方法都是隐式final的。</p>

<p>一个既是static又是final的域（编译器常量）是恒定不变的，且存储于一段不能改变的存储空间。</p>

<pre><code class="language-java">class Value {
    int i;
    public Value(int i) {
        this.i = i;
    }
}

public class House {
    private static Random rand = new Random(47);
    private String id;

    public House(String id) {
        this.id = id;
    }

    // 编译常量
    private final int valueOne = 9;
    private static final int VALUE_TWO = 99;
    public static final int VALUE_THREE = 39;
    // 非编译常量
    private final int i4 = rand.nextInt(20);
    static final int INT_5 = rand.nextInt(20);

    private Value v1 = new Value(11);
    private final Value v2 = new Value(22);
    private static final Value v3 = new Value(33);

    private final int[] a = { 1, 2, 3, 4, 5, 6, };

    public String toString() {
        return id + &quot;:&quot; + &quot;i4=&quot; + i4 + &quot;. INT_5=&quot; + INT_5;
    }

    public static void main(String[] args) {
        House fd1 = new House(&quot;fd1&quot;);
        // ! fd1.valueOne++ // Error: 不能改变值
        fd1.v2.i++; // 对象不是常量
        fd1.v1 = new Value(9);
        // ! fd1.v2 = new Value(9); // Error: 对象为final
        for (int i = 0; i &lt; fd1.a.length; i++) {
            fd1.a[i]++;// 数组对象也不是常量
        }
        // ! fd1.a = new int[3]; // Error: 数组对象为final
        System.out.println(fd1);
        System.out.println(&quot;Create new data&quot;);
        House fd2 = new House(&quot;fd2&quot;);
        System.out.println(fd1);
        System.out.println(fd2);
    }
} /* Output:
fd1:i4=15. INT_5=18
Create new data
fd1:i4=15. INT_5=18
fd2:i4=13. INT_5=18
*/
</code></pre>

<p>4，类的构造器调用遵循以下顺序</p>

<ol>
<li><p>调用static初始化语句。</p></li>

<li><p>将要分配给对象的存储空间初始化成二进制零。</p></li>

<li><p>调用基类构造器。</p></li>

<li><p>按声明顺序调用成员的初始化方法。</p></li>

<li><p>调用导出类构造器的主体。</p></li>
</ol>

<h2 id="inte">接口</h2>

<p>1, Java接口中的成员变量默认都是public static final类型的(都可省略)，必须被显示初始化，即接口中的成员变量为常量(大写，单词之间用&rdquo;_&ldquo;分隔)。Java接口中的方法默认都是public,abstract类型的(都可省略)，没有方法体，不能被实例化。</p>

<pre><code class="language-java">public interface A {
    int CONST = 1; //合法,CONST默认为public,static,final类型
    void method(); //合法,method()默认为public,abstract类型
    public abstract void method2(); //method2()显示声明为public,abstract类型
}
</code></pre>

<p>3, Java接口中只能包含public,static,final类型的成员变量和public,abstract类型的成员方法。接口中不能有构造方法，不能被实例化。</p>

<pre><code class="language-java">public interface A {
   int var; //错,var是常量,必须显示初始化
   public A(){...}; //错,接口中不能包含构造方法
   void method(){...};   //错,接口中只能包含抽象方法
   protected void method2(); //错,接口中的方法必须是public类型
   static void method3(){...};   //错,接口中不能包含静态方法
}
</code></pre>

<p>5, 一个接口不能实现(implements)另一个接口,但它可以继承多个其它的接口（多继承！！！）。</p>

<p>6, 当类实现了某个Java接口时,它必须实现接口中的所有抽象方法,否则这个类必须声明为抽象的。</p>

<p>8, 不允许创建接口的实例(实例化),但允许定义接口类型的引用变量,该引用变量引用实现了这个接口的类的实例（多态）。</p>

<p>比较抽象类和接口：</p>

<p>相同点</p>

<ul>
<li><p>都代表系统的抽象层,当一个系统使用一颗继承树上的类时,应该尽量把引用变量声明为继承树的上层抽象类型,这样可以提高两个系统之间的松耦合</p></li>

<li><p>都不能被实例化</p></li>

<li><p>都包含抽象方法,这些抽象方法用于描述系统能提供哪些服务,但不提供具体的实现</p></li>
</ul>

<p>不同点</p>

<ul>
<li><p>抽象类中可以对部分方法进行实现，而接口中全部是抽象方法。</p></li>

<li><p>一个类只能继承一个父类（抽象类），却可以实现多个接口。</p></li>

<li><p>接口可以继承多个接口，抽象类只能继承一个抽象类。</p></li>

<li><p>接口中的变量默认都是public static final常量，方法都是public abstract。</p></li>
</ul>

<h2 id="inne">内部类</h2>

<p>内部类是一个编译时的概念，一旦编译成功，就会成为完全不同的两类。对于一个名为outer的外部类和其内部定义的名为inner的内部类。编译完成后出现outer.class和outer$inner.class两类。所以内部类的成员变量/方法名可以和外部类的相同。</p>

<p>1，内部类可以分为在类中的内部类（成员内部类和静态内部类）以及在方法中的内部类（局部内部类和<strong>匿名内部类</strong>）。</p>

<p>2，成员内部类和静态内部类都可以与外围类相互访问，即使是私有域，静态内部类只能访问其外围类的静态成员，除此之外与成员内部类没有任何区别。</p>

<pre><code class="language-java">// 代码1：内部类对外部类可见
class Outer{
    //创建私有内部类对象
    public Inner in=new Inner();

    //私有内部类
    private class Inner{
         ...
    }
}

//代码2：外部类对内部类可见
//(内部类可以访问外部类的所有成员变量和方法)
class Outer{
    //外部类私有数据域
    private int data=0;

    //内部类
    class Inner{
        void print(){
            //内部类访问外部私有数据域
            System.out.println(data);
        }
    }
}

//代码3：静态内部类对外部变量的引用
public class Outer{
    private static int i=0;

    //创建静态内部类对象
    public Inner in=new Inner();

    //静态内部类
    private static class Inner{
        public void print(){
            System.out.println(i);   //如果i不是静态变量，这里将无法通过编译
        }
    }
}
</code></pre>

<p>3，局部内部类没有访问修饰符，对包围它的方法之外的任何东西都不可见；局部内部类只能够访问该方法中的局部变量，且这些局部变量一定要是final修饰的常量。匿名内部类就是没有名字的局部内部类，它没有构造器，<strong>它隐式的继承了一个父类或者实现了一个接口</strong>。</p>

<pre><code class="language-java">class Outter{
    public void outMethod(){
        final int beep=0;
        class Inner{
            //使用beep
        }

        Inner in=new Inner();
    }
}
</code></pre>

<h2 id="coll">容器类</h2>

<p>1，数组（非容器）：将数字与对象联系起来，保存类型明确的对象，可以是多维的，但是数组一旦生成其大小不能改变。</p>

<p>2，容器可以分为Collection和Map：Collection保存单一的元素，主要有List、Set等派生接口；Map则以名值对的方式存储。常用的容器有ArrayList/LinkedList、HashSet和HashMap。</p>

<p>3，List的特点是有顺序而可以重复，Set的特点是无顺序而不可重复。重复不是指容器中装了两个相同的对象，而是他们的值相等，因此自定义对象作为容器的储存元素时，我们必须重写java.lang.Object的equals方法（同时也应重写hashCode方法），Object的默认equals只有当比较的参数是本身时才返回true。</p>

<p>4，ArrayList实现了大小可变的数组，get/set方法均为线性时间，add/remove则比较费时；LinkedList可以快速的add/remove，但get/set方法比较慢。也因此LinkedList常被用作栈和队列使用。</p>

<p>5，Set有两个派生接口HashSet和TreeSet。HashSet是为快速查找设计的Set，存入HashSet的对象必须定义hashCode()；Tree是保存次序的Set，底层为树结构，可以提取有序序列。LinkedHashSet派生自HashSet，具有HashSet的查询速度，同时维护了元素的插入顺序。</p>

<p>6，Map有两个派生接口HashMap和TreeMap。 HashMap使用对象的hashCode()进行快速查询，TreeMap基于红黑树，维护了名值对的次序。LinkedHashMap派生自HashMap，维护了元素的顺序。</p>

<p>7，一般情况下数据结构的选择：多查少改选ArrayList；多改少查选LinkedList；如果大量数据进行检索选Map。</p>

<p>8，一些开销较大的同步接口：Vector(&ndash;ArrayList)、HashTable(&ndash;HashMap)、Stack(&ndash;LinkedList)。</p>

<p>9，java.util.Collection是一个集合接口，定义了一些集合基本操作的通用方法（add/remove）；java.util.Collections是一个包装类，定义了一些集合操作的静态多态方法（sort/shuffle/synchronizedXXX），类似一个工具类。另：Arrays工具类也提供了一些对数组的静态操作方法。</p>

<p>10，Java集合中，判断两个对象是否相等的规则是：判断两个对象的hashCode是否相等，若不相等，则认为两个对象不相等，若hashCode相等则继续判断两个对象用equals运算是否相等，若相等则两个对象相等。</p>

<pre><code class="language-java">public class HashTest {
    private int i;

    public int getI() {
        return i;
    }

    public void setI(int i) {
        this.i = i;
    }

    // 若没有重写equals方法，对象不相等
    public boolean equals(Object object) {
        if (object == null) {
            return false;
        }
        if (object == this) {
            return true;
        }
        if (!(object instanceof HashTest)) {
            return false;
        }
        HashTest other = (HashTest) object;
        if (other.getI() == this.getI()) {
            return true;
        }
        return false;

    // 若没有重写hashCode方法，对象不相等
    public int hashCode() {
        return i % 10;
    }

    public final static void main(String[] args) {
        HashTest a = new HashTest();
        HashTest b = new HashTest();
        a.setI(1);
        b.setI(1);
        Set&lt;HashTest&gt; set = new HashSet&lt;HashTest&gt;();
        set.add(a);
        set.add(b);
        System.out.println(a.hashCode() == b.hashCode());
        System.out.println(a.equals(b));
        System.out.println(set);
    }
} /* Output:
true
true
[com.allenyip.test.HashTest@1]
*/
</code></pre>

<h2 id="exce">异常</h2>

<p>1，Throwable类是所有异常类的基类，他有两个派生类Error和Exception：Error是程序无法处理的错误，如StackOverFlow/OutOfMemoryError等，此类错误通常交给JVM处理。Exception则是程序本身可以处理的异常。</p>

<p>2，Exception又可以分为CheckedException和UncheckedException，其中UncheckedException（或叫RuntimeException）和Error一样是程序无法处理的，如ClassNotFoundException/IllegalArgumentException/NullPointerException/IndexOutOfBoundsException等。</p>

<p>3，使用try&hellip;catch&hellip;finally使用异常，可以更好的处理程序：</p>

<pre><code class="language-java">
public static void testException1() {
    int[] ints = new int[] { 1, 2, 3, 4 };
    System.out.println(&quot;异常出现前&quot;);
    try {
        System.out.println(ints[4]);
        System.out.println(&quot;我还有幸执行到吗&quot;);// 发生异常以后，后面的代码不能被执行
    } catch (IndexOutOfBoundsException e) {
        System.out.println(&quot;数组越界错误&quot;);
    }
    System.out.println(&quot;异常出现后&quot;);
} /*
异常出现前
数组越界错误
异常出现后
*/

public static void testException2() {
    int[] ints = new int[] { 1, 2, 3, 4 };
    System.out.println(&quot;异常出现前&quot;);
    System.out.println(ints[4]);
    System.out.println(&quot;我还有幸执行到吗&quot;);// 发生异常以后，他后面的代码不能被执行
} /*
异常出现前
Exception in thread &quot;main&quot; java.lang.ArrayIndexOutOfBoundsException: 4
*/
</code></pre>

<p>4，在catch语句块中可以使用throw语句重新抛出异常（方法中用throws声明抛出的异常），将异常抛出给上一个调用者；三个以上的异常链会丢失异常，使用x.initCause(xx);方法可以保存异常信息，使得在抛出另外一个异常的同时不丢失原来的异常。</p>

<p>5，try&hellip;catch&hellip;finally细节</p>

<ul>
<li><p>try 块：用于捕获异常。其后可接零个或多个catch块，如果没有catch块，则必须跟一个finally块。</p></li>

<li><p>catch 块：用于处理try捕获到的异常。</p></li>

<li><p>finally 块：无论是否捕获或处理异常，finally块里的语句都会被执行。<strong>当在try块或catch块中遇到return语句时，finally语句块将在方法返回之前被执行</strong>。在以下4种特殊情况下，finally块不会被执行：在finally语句块中发生了异常；在前面的代码中用了System.exit()退出程序；程序所在的线程死亡；关闭CPU。</p></li>
</ul>

<h2 id="stri">字符串</h2>

<p>1，Java字符串类(java.lang.String)是Java中使用最多的类，也是最为特殊的一个类。</p>

<ul>
<li><p>String类是final的，不可被继承。public final class String。</p></li>

<li><p>String类是的本质是字符数组char[], 并且其值不可改变。private final char value[];</p></li>

<li><p>String类对象有个特殊的创建的方式，就是直接指定比如String x = &ldquo;abc&rdquo;，&rdquo;abc&rdquo;就表示一个字符串对象。而x是&rdquo;abc&rdquo;对象的地址，也叫做&rdquo;abc&rdquo;对象的引用。</p></li>

<li><p>String对象可以通过“+”串联。串联后会生成新的字符串。也可以通过concat()来串联。</p></li>

<li><p>创建字符串的方式很多，归纳起来有三类：1）使用new关键字创建字符串，比如String s1 = new String(&ldquo;abc&rdquo;);2）直接指定。比如String s2 = &ldquo;abc&rdquo;;3）使用串联生成新的字符串。比如String s3 = &ldquo;ab&rdquo; + &ldquo;c&rdquo;;</p></li>

<li><p>Java运行时会维护一个String Pool（String池），用来存放运行时中产生的各种字符串 ，并且池中的字符串的内容不重复。</p></li>

<li><p>intern方法用于常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用， 如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用</p></li>
</ul>

<pre><code class="language-java">public class Test {
    public static void main(String[] args){
        String s0 = &quot;allen&quot;;
        String s1 = &quot;allen&quot;; // String也是对象，但与其他对象不同，字符串存在一个字符串池中。
        String s2 = &quot;al&quot; + &quot;len&quot;;
        System.out.println( s0 == s1 );
        System.out.println( s0 == s2 );

        String s3 = new String(&quot;allen&quot;); // 运行时才创建的对象
        System.out.println( s0 == s3 );

        String s4 = new String(&quot;allen&quot;);
        s4 = s4.intern();
        System.out.println( s0 == s4 );
    }
} /* Output:
true
true
false
true
*/
</code></pre>

<p>2，String对象的创建根据以下原理：</p>

<ol>
<li><p>当使用任何方式来创建一个字符串对象s时，Java运行时（运行中JVM）会拿着这个X在String池中找是否存在内容相同的字符串对象，如果不存在，则在池中创建一个字符串s，否则，不在池中添加。</p></li>

<li><p>Java中，只要使用new关键字来创建对象，则一定会（在堆区或栈区）创建一个新的对象。</p></li>

<li><p>使用直接指定或者使用纯字符串串联来创建String对象，则仅仅会检查维护String池中的字符串，池中没有就在池中创建一个，有则罢了！但绝不会在堆栈区再去创建该String对象。</p></li>

<li><p>使用包含变量的表达式来创建String对象，则不仅会检查维护String池，而且还会在堆栈区创建一个String对象。</p></li>
</ol>

<p>3，String类的主要用法：</p>

<ul>
<li><p>获取长度 str.length()。（数组是arr.length）</p></li>

<li><p>比较字符串：s1.equals(s2)判断内容是否相同、s1.compareTo(s2)判断大小关系、==判断内容与地址是否相同、s1.reagionMatches(&hellip;)判断部分相同</p></li>

<li><p>查找字符 s.charAt(index)</p></li>

<li><p>查找字符串位置 s1.indexOf(s2)返回s1中第一次s2出现位置、s1.indexOf(s2, fromIndex)从字符串的第fromIndex个字符开始检索。（类似有lastIndexOf）</p></li>

<li><p>字符串包含 s1.conatins(s2)</p></li>

<li><p>截取子串 s1.subString(beginIndex)/s1.subString(beginIndex, endIndex)</p></li>

<li><p>字符串替换 replace(oldChar, newChar)、replaceAll(regex, replacement)</p></li>

<li><p>去除首尾空格 s.trim()</p></li>

<li><p>转换成字符数组 s.toCharArray();</p></li>

<li><p>分割成字符串数组 s.split(regex);</p></li>
</ul>

<p>4，String StringBuffer StrnigBuilder的区别</p>

<ol>
<li><p>String是长度不可变的字符串常量(final类)，StringBuffer线程安全的长度可变的字符串变量，StrnigBuilder是非线程安全的长度可变的字符串变量。</p></li>

<li><p>如果操作少量数据，使用String；单线程操作大量数据，使用StrnigBuidler；多线程操作大量数据，使用StringBuffer。</p></li>

<li><p>String的“+”操作性能极差，若有大量此类操作则应考虑使用StringBuffer/StringBuilder。（实际上在JVM内部，String的+操作也会借助StringBuffer完成）</p></li>

<li><p>使用StringBuffer/StringBuilder应尽可能指定其容量Capacity（默认16）。</p></li>

<li><p>StringBuilder相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险，因此除非对性能要求很高，否则不建议使用。</p></li>
</ol>

<h2 id="type">类型信息</h2>

<p>1，在java中，所有的类型转换都是在运行时进行正确性检查的。这也是RTTI/RunTime Type Information的含义：在运行时，识别一个对象的类型信息（如类名、继承的基类、实现的接口等）。传统的RTTI在<strong>编译时</strong>已知道了所有类型；反射机制则在程序运行时发现和使用类型信息。</p>

<p>2，Java使用一个Class对象来创建类的所有“常规”对象，以执行其RTTI。生成Class对象的过程如下：当我们编写一个新的java类时，JVM就会帮我们编译成class对象，存放在同名的.class文件中。在运行时，当需要生成这个类的对象，JVM就会检查此类是否已经装载内存中。若是没有装载，则把.class文件装入到内存中（RTTI从本地获取，反射从网络获取）。若是装载，则根据class文件生成实例对象。</p>

<pre><code class="language-java">class Candy {
  static { System.out.println(&quot;Loading Candy&quot;); }
}

class Gum {
  static { System.out.println(&quot;Loading Gum&quot;); }
}

class Cookie {
  static { System.out.println(&quot;Loading Cookie&quot;); }
}

public class SweetShop {
  public static void main(String[] args) {
    System.out.println(&quot;inside main&quot;);
    new Candy();
    System.out.println(&quot;After creating Candy&quot;);
    try {
      Class.forName(&quot;Gum&quot;);
    } catch(ClassNotFoundException e) {
      System.out.println(&quot;Couldn't find Gum&quot;);
    }
    System.out.println(&quot;After Class.forName(\&quot;Gum\&quot;)&quot;);
    new Cookie();
    System.out.println(&quot;After creating Cookie&quot;);
  }
} /* Output:
inside main
Loading Candy
After creating Candy
Loading Gum
After Class.forName(&quot;Gum&quot;)
Loading Cookie
After creating Cookie
*/
</code></pre>

<p>3，获取Class实例有三种方式：利用对象调用getClass()方法；使用Class类的静态方法forName()，用类的名字获取一个Class实例；运用.class的方式来获取Class实例，对于基本数据类型的封装类，还可以采用.TYPE来获取相对应的基本数据类型的Class实例。</p>

<pre><code class="language-java">public class ClassTest {
    public static void main(String [] args)throws Exception{
        String str1=&quot;abc&quot;;
        Class cls1=str1.getClass();
        Class cls2=Class.forName(&quot;java.lang.String&quot;); // 必须是全名！
        Class cls3=String.class;
        System.out.println(cls1 == cls2);
        System.out.println(cls1 == cls3);
        Integer i = new Integer(1);
        System.out.println(i.TYPE);
    }
} /* Output:
true
true
int
*/
</code></pre>

<p>4，当不知道对象的类型而又需要构造对象时，可以使用newObj = oldObj.newInstance()方法，前提是这个类有默认的构造函数。该方法可能会产生InstantiationException和IllegalAccessException两种运行时异常。</p>

<p>5，使用instanceOf/isInstance和Class的==/equals的区别是，前者判断的是该类或者该类的派生类，后者只判断是否为该类。</p>

<p>6，代理分为静态代理和动态代理：静态代理由程序员创建或特定工具自动生成源代码，再对其编译。在程序运行前，代理类的.class文件就已经存在了；动态代理在程序运行时，运用反射机制动态创建而成。</p>

<pre><code class="language-java">//接口
interface Interface {
    void doSomething();
    void somethingElse(String arg);
}
//目标对象
class RealObject implement Interface {
    public void doSomething() {
        System.out.println(&quot;RealObject doSomething&quot;);
    }
    public void somethingElse(String arg) {
        System.out.println(&quot;RealObject somethingElse&quot; + arg);
    }
}
//简单代理对象
class SimpleProxy implements Interface {
    private Interface proxied;
    public SimpleProxy(Interface proxied) {
        this.proxied = proxied;
    }
    public void doSomething() {
        System.out.println(&quot;SimpleProxy doSomething&quot;);
        proxied.doSomething();
    }
    public void somethingElse(String arg) {
        System.out.println(&quot;SimpleProxy somethingElse&quot;+ arg);
        proxied.somethingElse(arg);
    }
}
Class SimpleProxyDemo {
    public static void consumer(Interface iface) {
        iface.doSomething();
        iface.somethingElse(&quot;TestProxy&quot;);
    }
    public static void main(String[] args) {
        //不用代理
        consumer(new RealObject());
        //使用代理
        consumer(new SimpleProxy(new RealObject()));
    }
}
 /* Output:
RealObject doSomething
RealObjectsomethingElse TestProxy
SimpleProxy doSomething
RealObject doSomething
SimpleProxy somethingElse TestProxy
RealObject somethingElse TestProxy
*/
</code></pre>

<p>7，Java内部的动态代理是针对接口的动态代理（可以使用第三方的cglib实现对类的动态代理），它需要：<strong>实现InvocationHandler接口并且实现其invoke()方法</strong>，该方法是代理调用目标对象方法以及提供额外操作的方法；<strong>使用Proxy.newProxyInstance(类加载器, 代理接口列表,InvocationHandler对象)方法创建实现了指定接口的动态代理</strong>。</p>

<pre><code class="language-java">import java.lang.reflect.*;
//接口
interface Interface {
    void doSomething();
    void somethingElse(String arg);
}
//目标对象
class RealObject implements Interface {
    public void doSomething() {
        System.out.println(&quot;RealObject doSomething&quot;);
    }
    public void somethingElse(String arg) {
        System.out.println(&quot;RealObject somethingElse&quot; + arg);
    }
}
//代理处理类
class DynamicProxyHandler implements InvocationHandler {
    private Object proxied;
    public DynamicProxyHandler(Object proxied){
        this.proxied = proxied;
    }
    //动态代理调用目标对象的方法
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable{
        System.out.println(&quot;Dynamic proxy invoke&quot;);
        return method.invoke(proxied, args);
    }
}
class SimpleDynamicProxy {
    public static void consumer(Interface iface){
        iface.doSomething();
        iface.somethingElse(&quot;DynamicProxy&quot;);
    }
    public static void main(String[] args){
        RealObject real = new RealObject();
        //不用代理
        consumer(real);
        //创建动态代理
        Interface proxy = (Interface) Proxy.newProxyInstance(
                        Interface.class.getClassLoader(),
                        new Class[]{Interface.class},
                        new DynamicProxyHandler(real)
        );
        consumer(proxy);
    }
} /* Output:
RealObject doSomething
RealObject somethingElseDynamicProxy
Dynamic proxy invoke
RealObject doSomething
Dynamic proxy invoke
RealObject somethingElseDynamicProxy
*/
</code></pre>

<h2 id="geri">泛型</h2>

<p>1，泛型是对Java语言的类型系统的一种扩展，以支持创建可以按类型进行参数化的类。使用泛型的动机如下：</p>

<pre><code class="language-java">// 不用泛型，需要强制转换类型，混乱麻烦且不安全
List myIntList = new LinkedList(); //1
myIntList.add(newInteger(0)); //2
Integer x = (Integer)myIntList.iterator().next(); //3

// 使用了泛型则安全简便
List&lt;Integer&gt; myIntList = newLinkedList&lt;Integer&gt;(); //1’
myIntList.add(newInteger(0)); //2’
Integerx = myIntList.iterator().next(); //3’
</code></pre>

<p>2，可以泛型将其理解成编译器层次的概念，在编译后的Java字节代码中是不包含泛型信息的。在编译时会执行<strong>类型擦除</strong>，即清除类型参数的相关信息，并且再必要的时候添加类型检查和类型转换的方法。（泛型中的所有动作都发生在边界处：对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型）</p>

<pre><code class="language-java">public interface List&lt;E&gt; {
    void add(E x);
    Iterator&lt;E&gt; iterator();
}
// 转换后的接口可以理解成：
public interface IntegerList {
    void add(Integer x)
    Iterator&lt;Integer&gt; iterator();
}
/* 重载时会导致编译时错误
 * List&lt;String&gt;和List&lt;Integer&gt;在运行时是相同类型，都被擦除成原生类型List
 */
public class Erasure{
    public void test(List&lt;String&gt; ls){
        System.out.println(&quot;Sting&quot;);
    }
    public void test(List&lt;Integer&gt; li){
        System.out.println(&quot;Integer&quot;);
    }
}
</code></pre>

<p>3，如果Foo是Bar的子类型，G是一种带泛型的类型，则G<Foo>不是G<Bar>的子类型。</p>

<p>4，通配符“?”指定可以使用任何类型的集合作为参数，表示类型未知，因此也无法添加除null意外的元素。使用通配符的规则如下：如果你想从一个数据类型里获取数据，使用 ? extends 通配符；如果你想把对象写入一个数据结构里，使用 ? super 通配符；如果你既想存，又想取，那就别用通配符。</p>

<p>5，使用泛型方法时，类型T应该位于返回值之前。关于泛型的一些种类，见<a href="http://www.cnblogs.com/sunwei2012/archive/2010/10/08/1845938.html。" rel="nofollow noreferrer" target="_blank">http://www.cnblogs.com/sunwei2012/archive/2010/10/08/1845938.html。</a></p>

<pre><code class="language-java">static void fromArrayToCollection(Object[]a, Collection&lt; ?&gt; c) {
    for (Object o:a) {
    c.add(o); //compile time error
    }
}
static &lt;T&gt; void fromArrayToCollection(T[] a, Collection&lt;T&gt;c){
    for(T o : a) {
        c.add(o);// correct
    }
}
</code></pre>

<h2 id="enum">枚举</h2>

<p>关于枚举的七个用法：</p>

<pre><code class="language-java">// 1. 常量
public enum Color {
  RED, GREEN, BLANK, YELLOW
}

// 2. switch
enum Signal {
    GREEN, YELLOW, RED
}
public class TrafficLight {
    Signal color = Signal.RED;
    public void change() {
        switch (color) {
        case RED:
            color = Signal.GREEN;
            break;
        case YELLOW:
            color = Signal.RED;
            break;
        case GREEN:
            color = Signal.YELLOW;
            break;
        }
    }
}

// 3. 向枚举中添加新方法
// 必须在enum实例序列的最后添加一个分号
// 必须先定义 enum 实例
public enum Color {
    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);
    // 成员变量
    private String name;
    private int index;
    // 构造方法
    private Color(String name, int index) {
        this.name = name;
        this.index = index;
    }
    // 普通方法
    public static String getName(int index) {
        for (Color c : Color.values()) {
            if (c.getIndex() == index) {
                return c.name;
            }
        }
        return null;
    }
    // get set 方法
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getIndex() {
        return index;
    }
    public void setIndex(int index) {
        this.index = index;
    }
}

// 4. 覆盖枚举的方法
public enum Color {
    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);
    // 成员变量
    private String name;
    private int index;
    // 构造方法
    private Color(String name, int index) {
        this.name = name;
        this.index = index;
    }
    //覆盖方法
    @Override
    public String toString() {
        return this.index+&quot;_&quot;+this.name;
    }
}

// 5. 实现接口
public interface Behaviour {
    void print();
    String getInfo();
}
public enum Color implements Behaviour{
    RED(&quot;红色&quot;, 1), GREEN(&quot;绿色&quot;, 2), BLANK(&quot;白色&quot;, 3), YELLO(&quot;黄色&quot;, 4);
    // 成员变量
    private String name;
    private int index;
    // 构造方法
    private Color(String name, int index) {
        this.name = name;
        this.index = index;
    }
//接口方法
    @Override
    public String getInfo() {
        return this.name;
    }
    //接口方法
    @Override
    public void print() {
        System.out.println(this.index+&quot;:&quot;+this.name);
    }
}

// 6. 使用接口组织枚举
public interface Food {
    enum Coffee implements Food{
        BLACK_COFFEE,DECAF_COFFEE,LATTE,CAPPUCCINO
    }
    enum Dessert implements Food{
        FRUIT, CAKE, GELATO
    }
}

// 7. 枚举集合java.util.EnumSet和java.util.EnumMap
// EnumSet保证集合中的元素不重复
// EnumMap中的key是enum类型，而value则可以是任意类型
</code></pre>

<h2 id="arra">数组</h2>

<p>关于数组的十二个最佳方法：</p>

<pre><code class="language-java">// 1. 声明一个数组有三种方式
int[] a = new int[3]; // 必须指定其大小 同int a[]
int[] b = { 1, 2, 3 }; // 同 { 1, 2, 3, }
int[] c = new int[]{ 1, 2, 3 }; // new后的[]由{}个数决定大小

// 2. 输出一个数组
int[] intArray = { 1, 2, 3 };
String intArrayString = Arrays.toString(intArray);
System.out.println(intArray);  // [I@7150bd4d
System.out.println(intArrayString); // [1, 2, 3]
// 也可通过循环输出，效率没有Arrays.toString高

// 3. 从一个数组创建数组列表
String[] stringArray = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };
ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(stringArray));
System.out.println(arrayList);// [a, b, c, d, e]

// 4. 检查一个数组是否包含某个值
String[] stringArray = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };
boolean b = Arrays.asList(stringArray).contains(&quot;a&quot;);

// 5. 连接两个数组
int[] intArray = { 1, 2, 3, 4, 5 };
int[] intArray2 = { 6, 7, 8, 9, 10 };
// Apache Commons Lang library
int[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);

// 6. 声明一个内联数组（Array inline）
method(new String[]{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;});

// 7. 把提供的数组元素放入一个字符串
// containing the provided list of elements
// Apache common lang
String j = StringUtils.join(new String[] { &quot;a&quot;, &quot;b&quot;, &quot;c&quot; }, &quot;, &quot;);
System.out.println(j);// a, b, c

// 8. 将一个数组列表转换为数组
String[] stringArray = { &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot; };
ArrayList&lt;String&gt; arrayList = new ArrayList&lt;String&gt;(Arrays.asList(stringArray));
String[] stringArr = new String[arrayList.size()];
arrayList.toArray(stringArr);
for (String s : stringArr)
    System.out.println(s);

// 9. 将一个数组转换为集（set）
Set&lt;String&gt; set = new HashSet&lt;String&gt;(Arrays.asList(stringArray));
System.out.println(set);//[d, e, b, c, a]

// 10. 逆向一个数组
int[] intArray = { 1, 2, 3, 4, 5 };
ArrayUtils.reverse(intArray);
System.out.println(Arrays.toString(intArray));//[5, 4, 3, 2, 1]

// 11. 移除数组中的元素
int[] intArray = { 1, 2, 3, 4, 5 };
int[] removed = ArrayUtils.removeElement(intArray, 3);//create a new array
System.out.println(Arrays.toString(removed));

// 12. 将整数转换为字节数组
byte[] bytes = ByteBuffer.allocate(4).putInt(8).array();
for (byte t : bytes) {
   System.out.format(&quot;0x%x &quot;, t);
}
</code></pre>

<h2 id="anno">注解</h2>

<p>1，内置的三个注解：@Override只能用在方法之上的，用来告诉别人这一个方法是改写父类的、@Deprecated建议别人不要使用旧的API，编译的时候会用产生警告信息、@SuppressWarnings可以暂时关闭警告信息。</p>

<p>2，自定义注解时，需要使用到四个元注解（即注解的注解）：@Retention定义注解的保留策略、@Target定义注解的作用目标、@Document说明该注解将被包含在javadoc中、@Inherited说明子类可以继承父类中的该注解。</p>

<pre><code class="language-java">import java.lang.annotation.*;
@Documented // 此注解会包含在javadoc中
@Target(ElementType.METHOD) // 用于方法
@Retention(RetentionPolicy.CLASS) // 默认，注解会在class字节码文件中存在，但运行时无法获得
public @interface Test {...}
</code></pre>

<h2 id="io">Java I/O</h2>

<p>1，Java中把不同的数据源与程序间的数据传输都抽象表述为&rdquo;流&rdquo;(Stream),java.io包中定义了多种I/O流类型实现数据I/O功能。I/O流可以分为输入流(Input Stream)和输出流(Output Stream)、节点流(Node Stream)和处理流(Processing Stream)、字符流(Character Stream)和字节流(Byte Stream)。</p>

<ol>
<li><p>按照数据流动的方向，java流可分为输入流(Input Stream)和输出流(Output Stream)。输入流只能从中读取数据，而不能向其写出数据；输出流则只能向其写出数据,而不能从中读取数据。（除java.io.RandomAccessFile类外）</p></li>

<li><p>根据数据流所关联的是数据源还是其他数据流,可分为节点流(Node Stream)和处理流(Processing Stream)。节点流直接连接到数据源；处理流是对一个已存在的流的连接和封装，通过封装的流的功能调用实现增强的数据读/写功能，处理流并不直接连接到数据源。（处理流无法直接操作文件，应基于节点流封装）</p></li>

<li><p>按传输数据的&rdquo;颗粒大小&rdquo;划分，可分为字符流(Character Stream)和字节流(Byte Stream)。字节流以字节为单位进行数据传输，每次传送一个或多个字节；字符流以字符为单位进行数据传输，每次传送一个或多个字符。Java命名惯例:
凡是以InputStream或OutputStream结尾的类型均为字节流，凡是以Reader或Writer结尾的均为字符流。</p></li>
</ol>

<p>2，Java I/O包括以下三个层次：</p>

<ol>
<li><p>File（文件特征与管理）：用于文件或者目录的描述信息，例如生成新目录，修改文件名，删除文件，判断文件所在路径等</p></li>

<li><p>InputStream（二进制格式输入操作）和OuputStream（二进制格式输出操作）两个抽象类，是所有输入/输出流的父类，定义了所有输入/输出流都具有的共同特征。</p></li>

<li><p>Reader（文件格式输入操作）和Writer（文件格式输出操作）两个抽象类，是基于字符的操作。由于Java中字符是采用Unicode标准，一个字符是16位，即一个字符使用两个字节来表示。为此，JAVA中引入了处理字符的流。</p></li>

<li><p>RandomAccessFile（随机文件操作）：功能丰富，可以从文件的任意位置进行存取（输入输出）操作。</p></li>
</ol>

<p>3，常用的Java I/O流类型</p>

<p>1）使用FileInputStream/FileOutputStream字节流实现文件的复制：FileInputStream用于读取本地文件中字节数据，FileOutputStram用于将字节数据写到文件</p>

<pre><code class="language-java">import java.io.*;
public class CopyFile{
    public static void main(String[] args) {
        try {
            FileInputStream fis = new FileInputStream (&quot;a.jpg&quot;);
            FileOutputStream fos = new FileOutputStream (&quot;temp.jpg&quot;);
            int read = fis.read();
            while ( read != -1 ) {
                fos.write(read);
                read = fis.read();
            }
            fis.close();
            fos.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>2）使用FileReader/FileWriter字符流实现文件的复制：FileReader用于以字符为单位读取文本文件，FileWriter类用于将字符数据写到文本文件中。</p>

<pre><code class="language-java">import java.io.*;
public class Test {
    public static void main(String[] args) {
        try {
            FileReader input = new FileReader(&quot;a.txt&quot;);
            FileWriter output = new FileWriter(&quot;temp.txt&quot;);
            int read = input.read();
            while ( read != -1 ) {
                output.write(read);
                read = input.read();
            }
            input.close();
            output.close();
        } catch (IOException e) {
            System.out.println(e);
        }
    }
}
</code></pre>

<p>3）使用BufferedReader/BufferedWriter字符处理流实现文件的复制：BufferedReader用于缓冲读取字符，BufferedWriter则是供字符的缓存写出功能。</p>

<pre><code class="language-java">import java.io.*;
public class Test {
    public static void main(String[] args) {
        try {
            FileReader input = new FileReader(&quot;Test.java&quot;);
            BufferedReader br = new BufferedReader(input);
            FileWriter output = new FileWriter(&quot;temp.txt&quot;);
            BufferedWriter bw = new BufferedWriter(output);
            String s = br.readLine();
            while ( s!=null ) {
                bw.write(s);
                bw.newLine();
                s = br.readLine();
            }
            br.close();
            bw.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
</code></pre>

<p>4）InputStreamReader封装字节输入流并从中读取字节数据,然后将之转换为字符，OutputStreamWriter按照特定的字符编码规则把字符转化为字节并写出到它所封装的字节输出流。</p>

<pre><code class="language-java">FileInputStream fis = new FileInputStream(&quot;a.txt&quot;);
InputStreamReader isr = new InputStreamReader(fis);

FileOutputStream fos = new FileOutputStream(&quot;b.txt&quot;);
OutputStreamWriter osw = new OutputStreamWriter(fos);
</code></pre>

<h2 id="conc">并发</h2>

<p>并发编程可以将程序划分为多个分离的、独立的任务，这些任务通过多线程机制分别由一个与之对应的线程驱动。</p>

<p>1，通过实现Runnable接口并重写其run()方法来定义一个任务：</p>

<pre><code class="language-java">public class LiftOff implements Runnable {
    protected int countDown = 10;
    private static int taskCount = 0;
    private final int id = taskCount++;

    public LiftOff() { }

    public LiftOff(int countDown) {
        this.countDown = countDown;
    }

    public String status() {
        return &quot;#&quot; + id + &quot;(&quot; + (countDown &gt; 0 ? countDown : &quot;Liftoff!&quot;) + &quot;),&quot;;
    }

    @Override
    public void run() {
        while (countDown-- &gt; 0) {
            System.out.println(status());
            Thread.yield(); // 该方法“建议”线程调度器进行任务切换
        }
    }
}
public class Test {
    public static void main(String[] args) {
        LiftOff launch = new LiftOff();
        launch.run(); // 并没有启动一个新线程，而是使用main线程
    }
} /* Output:
#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(Liftoff!)
*/
</code></pre>

<p>2，将Runnable对象转变为工作任务的传统方式是把它交给Thread构造器：</p>

<pre><code class="language-java">public class BasicThreads {
    public static void main(String[] args) {
        Thread t = new Thread(new LiftOff());
        t.start(); // 启动了新线程
        System.out.println(&quot;Waiting for LiftOff&quot;);
    }
} /* Output:
Waiting for LiftOff
#0(9),#0(8),#0(7),#0(6),#0(5),#0(4),#0(3),#0(2),#0(1),#0(Liftoff!)
*/
</code></pre>

<p>Thread类的start方法启动线程，先执行一些必须的初始化操作，后调用Runnable的run方法。此时main线程和LiftOff.run()两个线程同时执行。</p>

<p>3，java.util.concurrent.Executor用于管理Thread对象，从而简化并发编程。</p>

<pre><code class="language-java">public class CashedThreadPool {
    public static void main(String[] args) {
        ExecutorService exec = Executors.newCachedThreadPool();
        for(int i = 0; i &lt; 5; i++) {
            exec.execute(new LiftOff());
        }
        exec.shutdown();
    }
}
</code></pre>

<p>可以通过ExecutorService exec = Executors.newFixedThreadPool(5);来限定有限的线程集执行所提交的任务。</p>

<p>4，Runnable是执行工作的独立任务，它不返回任何值，若需要返回则应实现具有类型参数泛型的Callable接口。</p>

<p>5，sleep()方法使人物中止执行给定的时间，称为休眠。调用sleep()方法可以抛出InterruptedException异常。</p>

<p>6，可以通过Thread.currentThread()获取当前线程的对象。</p>

<p>7，可以通过setPriority(aIntPriority)设置线程的优先级，调度器倾向于先运行优先级高的线程但不一定，一般只使用MAX_PRIORITY/NORMAL_PRIORITY/MIN_PRIORITY三个优先级。</p>

<p>8，后台/daemon线程是指程序运行时在后台提供一种通用服务的线程，并且这种线程不是程序不可或缺的。因此当所有非后台线程结束时，程序终止，同时杀死进程中所有的后台线程；通过setDaemon()方法将一个线程设置成后台线程，通过isDaemon()方法判断一个线程是否后台线程。（后台线程创建的线程自动设置为后台线程）</p>

<p>9，还可以通过直接继承Thread类来实现线程，Thread类本身不执行任何操作，它只是驱动赋予它的任务。</p>

<p>10，线程具有开始（等待）、运行、挂起和停止四种不同的状态：</p>

<pre><code class="language-java">// 开始线程
public void start( );
public void run( );

// 挂起和唤醒线程
public void resume( );     // 不建议使用
public void suspend( );    // 不建议使用
public static void sleep(long millis);
public static void sleep(long millis, int nanos);

// 终止线程
public void stop( );       // 不建议使用
public void interrupt( );

// 得到线程状态
public boolean isAlive( );
public boolean isInterrupted( );
public static boolean interrupted( );

// join方法
public void join( ) throws InterruptedException;
</code></pre>

<p>TODO: 资源共享、线程写作、死锁..</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Allen Yip </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://allenyip.github.io/2013/java-basic/>https://allenyip.github.io/2013/java-basic/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://allenyip.github.io/tags/development/">
                    #development</a></span>
            
            <span class="tag"><a href="https://allenyip.github.io/tags/java/">
                    #java</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://allenyip.github.io/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
         
        
        <a href="https://allenyip.github.io/2013/the-it-crowd/" class="next" rel="next" title="看《IT狂人》">看《IT狂人》&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2019</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://allenyip.github.io/">Allen Yip</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
